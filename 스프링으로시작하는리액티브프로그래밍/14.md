# 14. Operators

## 14.2 Sequence 생성을 위한 Operator

### JustOrEmpty
* Just 는 emit 할 데이터가 null 일 경우, NullPointException 발생
* JustOrEmpty 는 emit 할 데이터가 null 일 경우, onCompleteSignal 을 전송
* `just(Optional.ofNullable(null))` -> onCompleteSignal
* `justOrEmpty(Optional.ofNullable(null))` -> onCompleteSignal

~~~Java
public static void main(String[] args) {
    Mono
            .justOrEmpty(null)
            .subscribe(data -> {},
                    error -> {},
                    () -> log.info("# onComplete"));
}
~~~

~~~
[main] INFO com.example.test.Example - # onComplete
~~~

### fromIterable
* Iterable 에 포함된 데이터를 emit 하는 Flux 생성

~~~Java
public static void main(String[] args) {
    Flux
            .fromIterable(SampleData.coins)
            .subscribe(coin ->
                    log.info("coin 명: {}, 현재가: {}", coin.getT1(), coin.getT2())
            );
}
~~~

~~~
08:18:32.636 [main] INFO com.example.test.Example - coin 명: BTC, 현재가: 52000000
08:18:32.640 [main] INFO com.example.test.Example - coin 명: ETH, 현재가: 1720000
08:18:32.640 [main] INFO com.example.test.Example - coin 명: XRP, 현재가: 533
08:18:32.641 [main] INFO com.example.test.Example - coin 명: ICX, 현재가: 2080
08:18:32.641 [main] INFO com.example.test.Example - coin 명: EOS, 현재가: 4020
08:18:32.641 [main] INFO com.example.test.Example - coin 명: BCH, 현재가: 558000
~~~

### fromStream
* stream 에 포함된 데이터를 emit 하는 Flux 를 생성
* stream 은 재사용할수 없으며, cancel, error, complete 시에 자동으로 닫힘

~~~Java
public static void main(String[] args) {
    Flux
        .fromStream(() -> SampleData.coinNames.stream())
        .filter(coin -> coin.equals("BTC") || coin.equals("ETH"))
        .subscribe(data -> log.info("{}", data));
}
~~~

~~~
08:20:03.850 [main] INFO com.example.test.Example - BTC
08:20:03.851 [main] INFO com.example.test.Example - ETH
~~~

### range
* n 부터 1씩 증가한 연속된 수를 emit 하는 Flux 를 생성

~~~Java
public static void main(String[] args) {
    Flux
        .range(5, 10)  // 5부터 시작해서 10개
        .subscribe(data -> log.info("{}", data));
}
~~~

~~~
08:21:55.673 [main] INFO com.example.test.Example - 5
08:21:55.674 [main] INFO com.example.test.Example - 6
08:21:55.674 [main] INFO com.example.test.Example - 7
08:21:55.674 [main] INFO com.example.test.Example - 8
08:21:55.674 [main] INFO com.example.test.Example - 9
08:21:55.674 [main] INFO com.example.test.Example - 10
08:21:55.674 [main] INFO com.example.test.Example - 11
08:21:55.674 [main] INFO com.example.test.Example - 12
08:21:55.674 [main] INFO com.example.test.Example - 13
08:21:55.674 [main] INFO com.example.test.Example - 14
~~~

### defer
* Operator 를 선언한 시점에 데이터를 emit 하지 않음
* 구독하는 시점에 데이터를 emit 하는 Flux, Mono 를 생성
* 데이터 emit 을 지연시키기 때문에 불필요한 프로세스를 줄일수 있음

~~~java
public static void main(String[] args) throws InterruptedException {
    log.info("# start: {}", LocalDateTime.now());
    Mono<LocalDateTime> justMono = Mono.just(LocalDateTime.now());
    Mono<LocalDateTime> deferMono = Mono.defer(() ->
                                                Mono.just(LocalDateTime.now()));

    Thread.sleep(2000);

    justMono.subscribe(data -> log.info("# onNext just1: {}", data));
    deferMono.subscribe(data -> log.info("# onNext defer1: {}", data));

    Thread.sleep(2000);

    justMono.subscribe(data -> log.info("# onNext just2: {}", data));
    deferMono.subscribe(data -> log.info("# onNext defer2: {}", data));
}
~~~

~~~
08:26:31.451 [main] INFO com.example.test.Example - # start: 2024-04-04T08:26:31.440
08:26:33.575 [main] INFO com.example.test.Example - # onNext just1: 2024-04-04T08:26:31.455
08:26:33.576 [main] INFO com.example.test.Example - # onNext defer1: 2024-04-04T08:26:33.576
08:26:35.583 [main] INFO com.example.test.Example - # onNext just2: 2024-04-04T08:26:31.455
08:26:35.583 [main] INFO com.example.test.Example - # onNext defer2: 2024-04-04T08:26:35.583
~~~

* deferMono 는 2초의 간격을 두고 emit 됨
  * `08:26:33.576` -> `08:26:35.583` 
* justMono 의 경우 지연 시간과 상관없이 동일한 시간을 출력함
  * `08:26:31.455`
* justMono 가 동일한 시간을 출력하는 이유?
  * Just 는 Hot Publisher 이기 때문에, Subscriber 의 구독 여부와 상관없이 데이터를 emit 함
  * 구독이 발생하면 emit 된 데이터를 replay 해서 Subscriber 에게 전달함
  * 따라서 justMono 의 경우 출력 결과가 같음


~~~java
public static void main(String[] args) throws InterruptedException {
    log.info("# start: {}", LocalDateTime.now());
    Mono
        .just("Hello")
        .delayElement(Duration.ofSeconds(3))
        .switchIfEmpty(sayDefault())
//      .switchIfEmpty(Mono.defer(() -> sayDefault()))
        .subscribe(data -> log.info("# onNext: {}", data));

    Thread.sleep(3500);
}

private static Mono<String> sayDefault() {
    log.info("# Say Hi");
    return Mono.just("Hi");
}
~~~

~~~
// `.switchIfEmpty(sayDefault())` -> sayDefault() 호출됨
08:35:22.647 [main] INFO com.example.test.Example - # start: 2024-04-04T08:35:22.635
08:35:22.736 [main] INFO com.example.test.Example - # Say Hi
08:35:25.762 [parallel-1] INFO com.example.test.Example - # onNext: Hello
~~~

~~~
// `.switchIfEmpty(Mono.defer(() -> sayDefault()))` -> sayDefault() 호출되지 않음
08:40:24.108 [main] INFO com.example.test.Example - # start: 2024-04-04T08:40:24.098
08:40:27.225 [parallel-1] INFO com.example.test.Example - # onNext: Hello
~~~

* `.switchIfEmpty(sayDefault())`
  * sayDefault 가 호출되지 않을것 처럼 보이지만 실제로 호출됨
* `.switchIfEmpty(Mono.defer(() -> sayDefault()))`
  * defer 를 사용하면 불필요한 호출을 막을수 있음


### using
* parameter 로 전달받은 resource 를 emit 하는 Flux 를 생성
* resourceSupplier
  * 읽어올 resource
* sourceSupplier
  * 읽어온 resource 를 emit 하는 Flux
* resourceCleanup
  * 종료 signal(onComplete 또는 onError)이 발생할 경우 resource 를 해제하는 등의 후처리를 할수 있게 함

~~~
public static <T, D> Flux<T> using(Callable<? extends D> resourceSupplier, 
                                   Function<? super D, ? extends Publisher<? extends T>> sourceSupplier, 
                                   Consumer<? super D> resourceCleanup) {
}
~~~

~~~java
public static void main(String[] args) throws IOException {
    Path path = new ClassPathResource("using_example.txt").getFile().toPath();

    Flux
            .using(() -> Files.lines(path), Flux::fromStream, Stream::close)
            .subscribe(log::info);
}
~~~

~~~
08:53:51.938 [main] INFO com.example.test.Example - test line1
08:53:51.938 [main] INFO com.example.test.Example - test line2
08:53:51.939 [main] INFO com.example.test.Example - test line3
~~~

### generate
* 프로그래밍 방식으로 Signal 이벤트를 발생시킴
* 동기적으로 데이터를 하나씩 순차적으로 emit 하고자 할때 사용
* SynchronousSink
  * 하나의 signal 만 동기적으로 발생시킬수 있으며, 최대 하나의 상태값만 emit 하는 인터페이스 

~~~java
public static <T, S> Flux<T> generate(Callable<S> stateSupplier, 
                                      BiFunction<S, SynchronousSink<T>, S> generator) {
}
~~~

~~~java
public static void main(String[] args) {
    Flux
            .generate(
                    () -> 0,  // 초깃값을 0으로 지정
                    (state, sink) -> {
                        sink.next(state);
                        if (state == 10)
                            sink.complete();  // onComplete signal 을 발생시켜 Sequence 가 종료되도록 함
                        return ++state;
                    })
            .subscribe(data -> log.info("# onNext: {}", data));
}
~~~

~~~
09:00:13.691 [main] INFO com.example.test.Example - # onNext: 0
09:00:13.692 [main] INFO com.example.test.Example - # onNext: 1
09:00:13.692 [main] INFO com.example.test.Example - # onNext: 2
09:00:13.692 [main] INFO com.example.test.Example - # onNext: 3
09:00:13.692 [main] INFO com.example.test.Example - # onNext: 4
09:00:13.692 [main] INFO com.example.test.Example - # onNext: 5
09:00:13.692 [main] INFO com.example.test.Example - # onNext: 6
09:00:13.692 [main] INFO com.example.test.Example - # onNext: 7
09:00:13.692 [main] INFO com.example.test.Example - # onNext: 8
09:00:13.692 [main] INFO com.example.test.Example - # onNext: 9
09:00:13.692 [main] INFO com.example.test.Example - # onNext: 10
~~~

* tuple 객체 사용하여 구구단 3단을 출력하는 예제

~~~java
public static void main(String[] args) {
    final int dan = 3;
    Flux
            .generate(
                    () -> Tuples.of(dan, 1),
                    (state, sink) -> {
                        sink.next(state.getT1() + " * " + state.getT2() + " = " + state.getT1() * state.getT2());
                        if (state.getT2() == 9) {
                            sink.complete();
                        }

                        return Tuples.of(state.getT1(), state.getT2() + 1);
                    }, 
                    state -> log.info("# 구구단 {}단 종료!", state.getT1()))
            .subscribe(data -> log.info("# onNext: {}", data));
}
~~~

~~~
09:07:46.571 [main] INFO com.example.test.Example - # onNext: 3 * 1 = 3
09:07:46.572 [main] INFO com.example.test.Example - # onNext: 3 * 2 = 6
09:07:46.572 [main] INFO com.example.test.Example - # onNext: 3 * 3 = 9
09:07:46.572 [main] INFO com.example.test.Example - # onNext: 3 * 4 = 12
09:07:46.572 [main] INFO com.example.test.Example - # onNext: 3 * 5 = 15
09:07:46.572 [main] INFO com.example.test.Example - # onNext: 3 * 6 = 18
09:07:46.572 [main] INFO com.example.test.Example - # onNext: 3 * 7 = 21
09:07:46.572 [main] INFO com.example.test.Example - # onNext: 3 * 8 = 24
09:07:46.572 [main] INFO com.example.test.Example - # onNext: 3 * 9 = 27
09:07:46.572 [main] INFO com.example.test.Example - # 구구단 3단 종료!
~~~

### create
* generate 처럼 프로그래밍 방식으로 Signal 이벤트를 발생시킴
* generate 와 차이점
  * generate 는 데이터를 동기적으로 한번에 한건씩 emit 함
  * create 는 데이터를 비동기적으로 한번에 여러건 emit 할수 있음

#### pull 방식으로 데이터 처리
~~~java
public class Example {
    static int SIZE = 0;
    static int COUNT = -1;
    final static List<Integer> DATA_SOURCE = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

    public static void main(String[] args) {
        log.info("# start");
        Flux.create((FluxSink<Integer> sink) -> {
            sink.onRequest(n -> {
                try {
                    Thread.sleep(1000L);
                    for (int i = 0; i < n; i++) {
                        if (COUNT >= 9) {
                            sink.complete();
                        } else {
                            COUNT++;
                            sink.next(DATA_SOURCE.get(COUNT));
                        }
                    }
                } catch (InterruptedException e) {}
            });

            sink.onDispose(() -> log.info("# clean up"));
        }).subscribe(new BaseSubscriber<Integer>() {
            @Override
            protected void hookOnSubscribe(Subscription subscription) {
                request(2);
            }

            @Override
            protected void hookOnNext(Integer value) {
                SIZE++;
                log.info("# onNext: {}", value);
                if (SIZE == 2) {
                    request(2);
                    SIZE = 0;
                }
            }

            @Override
            protected void hookOnComplete() {
                log.info("# onComplete");
            }
        });
    }
}
~~~

* 구독이 발생하면 hookOnSubscribe 에서 request(2) 를 호출하여 한번에 두개의 데이터를 요청
* sink.onRequest 메서드의 람다 표현식이 실행됨
* sink.next 로 지정한 개수 만큼 emit 함
* hookOnNext 에서 emit 된 데이터를 로그로 출력하고, request(2) 로 다시 2개의 데이터를 요청
* dataSource List 의 숫자를 모두 emit 하면 sink.complete 로 onComplete signal 을 발생 시킴
* hookOnComplete 에서 종료 로그를 출력
* sink.onDispose 에 람다 표현식이 실행되어 후처리 로그를 출력

~~~
09:12:53.811 [main] INFO com.example.test.Example - # start
09:12:55.037 [main] INFO com.example.test.Example - # onNext: 1
09:12:55.046 [main] INFO com.example.test.Example - # onNext: 2
09:12:56.049 [main] INFO com.example.test.Example - # onNext: 3
09:12:56.049 [main] INFO com.example.test.Example - # onNext: 4
09:12:57.054 [main] INFO com.example.test.Example - # onNext: 5
09:12:57.055 [main] INFO com.example.test.Example - # onNext: 6
09:12:58.057 [main] INFO com.example.test.Example - # onNext: 7
09:12:58.057 [main] INFO com.example.test.Example - # onNext: 8
09:12:59.064 [main] INFO com.example.test.Example - # onNext: 9
09:12:59.065 [main] INFO com.example.test.Example - # onNext: 10
09:13:00.072 [main] INFO com.example.test.Example - # onComplete
09:13:00.085 [main] INFO com.example.test.Example - # clean up
~~~

#### push 방식으로 데이터 처리
* 암호 화폐의 가격 변동이 있을때마다 변동되는 가격 데이터를 Subscriber 에게 비동기적으로 emit 하는 코드

~~~java
public class Example {
    public interface CryptoCurrencyPriceListener {
        void onPrice(List<Integer> priceList);
        void onComplete();
    }
    
    public static class CryptoCurrencyPriceEmitter {
        private CryptoCurrencyPriceListener listener;

        public void setListener(CryptoCurrencyPriceListener listener) {
            this.listener = listener;
        }

        public void flowInto() {
            listener.onPrice(Arrays.asList(50_000_000, 50_100_000, 50_700_000, 51_500_000, 52_000_000));
        }

        public void complete() {
            listener.onComplete();
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        CryptoCurrencyPriceEmitter priceEmitter = new CryptoCurrencyPriceEmitter();

        Flux.create((FluxSink<Integer> sink) ->
                        priceEmitter.setListener(new CryptoCurrencyPriceListener() {
                            @Override
                            public void onPrice(List<Integer> priceList) {
                                priceList.forEach(sink::next);
                            }

                            @Override
                            public void onComplete() {
                                sink.complete();
                            }
                        }))
                .publishOn(Schedulers.parallel())
                .subscribe(
                        data -> log.info("# onNext: {}", data),
                        error -> {},
                        () -> log.info("# onComplete"));

        Thread.sleep(3000L);
        log.info("# priceEmitter.flowInto");
        priceEmitter.flowInto();

        Thread.sleep(2000L);
        log.info("# priceEmitter.complete");
        priceEmitter.complete();
        Thread.sleep(2000L);
    }
}
~~~

* 가격 변동이 있을때마다 onPrice() 메서드가 호출됨
* 가격 변동을 발생시키기 위해 flowInto() 메서드를 호출

~~~
09:34:08.840 [main] INFO com.example.test.Example - # priceEmitter.flowInto
09:34:08.850 [parallel-1] INFO com.example.test.Example - # onNext: 50000000
09:34:08.855 [parallel-1] INFO com.example.test.Example - # onNext: 50100000
09:34:08.855 [parallel-1] INFO com.example.test.Example - # onNext: 50700000
09:34:08.855 [parallel-1] INFO com.example.test.Example - # onNext: 51500000
09:34:08.855 [parallel-1] INFO com.example.test.Example - # onNext: 52000000
09:34:10.855 [main] INFO com.example.test.Example - # priceEmitter.complete
09:34:10.859 [parallel-1] INFO com.example.test.Example - # onComplete
~~~

#### backpressure 방식으로 데이터 처리
* 한번에 여러건의 데이터를 비동기적으로 emit 할수 있기 때문에 Backpressure 전략이 필요

~~~java
public class Example {
    static int start = 1;
    static int end = 4;

    public static void main(String[] args) throws InterruptedException {
        Flux.create((FluxSink<Integer> emitter) -> {
                            emitter.onRequest(n -> {
                                log.info("# requested: " + n);
                                try {
                                    Thread.sleep(500L);
                                    for (int i = start; i <= end; i++) {
                                        emitter.next(i);
                                    }
                                    start += 4;
                                    end += 4;
                                } catch (InterruptedException e) {
                                }
                            });

                            emitter.onDispose(() -> {
                                log.info("# clean up");
                            });
                        },
                        FluxSink.OverflowStrategy.DROP)
                .subscribeOn(Schedulers.boundedElastic())
                .publishOn(Schedulers.parallel(), 2)
                .subscribe(data -> log.info("# onNext: {}", data));

        Thread.sleep(3000L);
    }

}
~~~

~~~
09:37:00.411 [boundedElastic-1] INFO com.example.test.Example - # requested: 2
09:37:00.915 [parallel-1] INFO com.example.test.Example - # onNext: 1
09:37:00.923 [parallel-1] INFO com.example.test.Example - # onNext: 2
09:37:00.932 [boundedElastic-1] INFO com.example.test.Example - # requested: 2
09:37:01.439 [parallel-1] INFO com.example.test.Example - # onNext: 5
09:37:01.439 [parallel-1] INFO com.example.test.Example - # onNext: 6
09:37:01.440 [boundedElastic-1] INFO com.example.test.Example - # requested: 2
09:37:01.945 [parallel-1] INFO com.example.test.Example - # onNext: 9
09:37:01.945 [parallel-1] INFO com.example.test.Example - # onNext: 10
09:37:01.946 [boundedElastic-1] INFO com.example.test.Example - # requested: 2
09:37:02.450 [parallel-1] INFO com.example.test.Example - # onNext: 13
09:37:02.451 [parallel-1] INFO com.example.test.Example - # onNext: 14
09:37:02.452 [boundedElastic-1] INFO com.example.test.Example - # requested: 2
09:37:02.957 [parallel-1] INFO com.example.test.Example - # onNext: 17
09:37:02.958 [parallel-1] INFO com.example.test.Example - # onNext: 18
09:37:02.959 [boundedElastic-1] INFO com.example.test.Example - # requested: 2
~~~

## 14.3 Sequence 필터링

### filter
* emit 된 데이터 중에서 조건에 일치하는 데이터만 Downstream 으로 emit

~~~java
public static void main(String[] args) {
    Flux
        .range(1, 20)
        .filter(num -> num % 2 != 0)
        .subscribe(data -> log.info("# onNext: {}", data));
}
~~~

~~~
09:39:51.035 [main] INFO com.example.test.Example - # onNext: 1
09:39:51.036 [main] INFO com.example.test.Example - # onNext: 3
09:39:51.036 [main] INFO com.example.test.Example - # onNext: 5
09:39:51.036 [main] INFO com.example.test.Example - # onNext: 7
09:39:51.036 [main] INFO com.example.test.Example - # onNext: 9
09:39:51.036 [main] INFO com.example.test.Example - # onNext: 11
09:39:51.036 [main] INFO com.example.test.Example - # onNext: 13
09:39:51.036 [main] INFO com.example.test.Example - # onNext: 15
09:39:51.036 [main] INFO com.example.test.Example - # onNext: 17
09:39:51.036 [main] INFO com.example.test.Example - # onNext: 19
~~~

### filterWhen
* Inner Sequence 를 통해 조건에 맞는 데이터인지를 비동기적으로 필터링을 수행
* 테스트 결과가 true 라면 Downstream 으로 emit 함 

~~~java
public static void main(String[] args) throws InterruptedException {
    Map<CovidVaccine, Tuple2<CovidVaccine, Integer>> vaccineMap = getCovidVaccines();
    Flux
            .fromIterable(SampleData.coronaVaccineNames)
            .filterWhen(vaccine -> Mono
                    .just(vaccineMap.get(vaccine).getT2() >= 3_000_000)
                    .publishOn(Schedulers.parallel()))
            .subscribe(data -> log.info("# onNext: {}", data));

    Thread.sleep(1000);
}
~~~


### skip
* 파라미터로 입력 받은 숫자만큼 건너뛴 후, Downstream 으로 emit
* 시간 단위로 건너뛰기도 가능

~~~java
public final Flux<T> skip(long skipped)
public final Flux<T> skip(Duration timespan)
~~~

* 숫자로 skip

~~~java
public static void main(String[] args) throws InterruptedException {
    Flux
            .interval(Duration.ofSeconds(1))
            .skip(2)
            .subscribe(data -> log.info("# onNext: {}", data));

    Thread.sleep(5500L);
}
~~~

* interval 로 1초에 한번씩 데이터를 emit 함
* `Thread.sleep(5500L)` main thread 가 5.5 초까지 실행되므로 0-4 까지 5개가 subscriber 로 전달됨  
* 0부터 증가하기 때문에 skip 으로 0,1 출력되지 않음

~~~
09:45:45.687 [parallel-1] INFO com.example.test.Example - # onNext: 2
09:45:46.691 [parallel-1] INFO com.example.test.Example - # onNext: 3
09:45:47.688 [parallel-1] INFO com.example.test.Example - # onNext: 4
~~~

* 시간단위로 skip

~~~java
public static void main(String[] args) throws InterruptedException {
    Flux
        .interval(Duration.ofMillis(300))
        .skip(Duration.ofSeconds(1))
        .subscribe(data -> log.info("# onNext: {}", data));

    Thread.sleep(2000L);
}
~~~

* interval 0.3 초씩 데이터를 emit 함
* 1초 skip 하여 0.9초까지 만들어진 0,1,2 가 skip 됨

~~~
09:51:17.108 [parallel-2] INFO com.example.test.Example - # onNext: 3
09:51:17.407 [parallel-2] INFO com.example.test.Example - # onNext: 4
09:51:17.706 [parallel-2] INFO com.example.test.Example - # onNext: 5
~~~


### take
* 파라미터로 입력 받는 숫자만큼 emit
  * skip 은 파라미터로 입력 받는 숫자만큼 건너뛰고 emit
* 시간 단위로 emit 도 가능

~~~java
public final Flux<T> take(long n)
public final Flux<T> take(Duration timespan)
~~~

~~~java
public static void main(String[] args) throws InterruptedException {
    Flux
        .interval(Duration.ofSeconds(1))
        .take(3)
        .subscribe(data -> log.info("# onNext: {}", data));

    Thread.sleep(4000L);
}
~~~

~~~
10:03:37.370 [parallel-1] INFO com.example.test.Example - # onNext: 0
10:03:38.367 [parallel-1] INFO com.example.test.Example - # onNext: 1
10:03:39.363 [parallel-1] INFO com.example.test.Example - # onNext: 2
~~~

### takeLast
* 파라미터로 입력 받은 개수만큼 가장 마지막에 emit 된 데이터를 Downstream 으로 emit

~~~java
public static void main(String[] args) {
    Flux
            .fromIterable(Arrays.asList(
                    Tuples.of(2010, 565L),
                    Tuples.of(2011, 36_094L),
                    Tuples.of(2012, 17_425L),
                    Tuples.of(2013, 1_405_209L),
                    Tuples.of(2014, 1_237_182L),
                    Tuples.of(2015, 557_603L),
                    Tuples.of(2016, 1_111_811L),
                    Tuples.of(2017, 22_483_583L),
                    Tuples.of(2018, 19_521_543L),
                    Tuples.of(2019, 15_761_568L),
                    Tuples.of(2020, 22_439_002L),
                    Tuples.of(2021, 63_364_000L)
            ))
            .takeLast(2)
            .subscribe(tuple -> log.info("# onNext: {}, {}", tuple.getT1(), tuple.getT2()));
}
~~~

* 가장 마지막 2 개인 2020, 2021 출력됨

~~~
10:06:24.447 [main] INFO com.example.test.Example - # onNext: 2020, 22439002
10:06:24.449 [main] INFO com.example.test.Example - # onNext: 2021, 63364000
~~~

### takeUntil
* 파라미터로 입력한 람다 표현식(Predicate)이 true 가 될때까지 Downstream 으로 emit
* Predicate 를 평가할때 사용한 데이터가 포함

~~~java
public static void main(String[] args) {
    Flux
            .fromIterable(Arrays.asList(
                    Tuples.of(2010, 565L),
                    Tuples.of(2011, 36_094L),
                    Tuples.of(2012, 17_425L),
                    Tuples.of(2013, 1_405_209L),
                    Tuples.of(2014, 1_237_182L),
                    Tuples.of(2015, 557_603L),
                    Tuples.of(2016, 1_111_811L),
                    Tuples.of(2017, 22_483_583L),
                    Tuples.of(2018, 19_521_543L),
                    Tuples.of(2019, 15_761_568L),
                    Tuples.of(2020, 22_439_002L),
                    Tuples.of(2021, 63_364_000L)
            ))
            .takeUntil(tuple -> tuple.getT2() > 20_000_000)
            .subscribe(tuple -> log.info("# onNext: {}, {}", tuple.getT1(), tuple.getT2()));
}
~~~

* 20_000_000 이상인 데이터가 처음 나오는 시점은 2017 
* Predicate 를 평가할때 사용한 데이터가 포함되기 때문에 2017 까지 출력됨

~~~
10:09:19.856 [main] INFO com.example.test.Example - # onNext: 2010, 565
10:09:19.858 [main] INFO com.example.test.Example - # onNext: 2011, 36094
10:09:19.858 [main] INFO com.example.test.Example - # onNext: 2012, 17425
10:09:19.858 [main] INFO com.example.test.Example - # onNext: 2013, 1405209
10:09:19.858 [main] INFO com.example.test.Example - # onNext: 2014, 1237182
10:09:19.858 [main] INFO com.example.test.Example - # onNext: 2015, 557603
10:09:19.858 [main] INFO com.example.test.Example - # onNext: 2016, 1111811
10:09:19.858 [main] INFO com.example.test.Example - # onNext: 2017, 22483583
~~~


### takeWhile
* 파라미터로 입력한 람다 표현식(Predicate)이 true 가 될때까지 Downstream 으로 emit
* Predicate 를 평가할때 사용한 데이터가 Downstream 으로 emit 되지 않음

~~~java
public static void main(String[] args) {
    Flux
            .fromIterable(Arrays.asList(
                    Tuples.of(2010, 565L),
                    Tuples.of(2011, 36_094L),
                    Tuples.of(2012, 17_425L),
                    Tuples.of(2013, 1_405_209L),
                    Tuples.of(2014, 1_237_182L),
                    Tuples.of(2015, 557_603L),
                    Tuples.of(2016, 1_111_811L),
                    Tuples.of(2017, 22_483_583L),
                    Tuples.of(2018, 19_521_543L),
                    Tuples.of(2019, 15_761_568L),
                    Tuples.of(2020, 22_439_002L),
                    Tuples.of(2021, 63_364_000L)
            ))
            .takeWhile(tuple -> tuple.getT2() < 20_000_000)
            .subscribe(tuple -> log.info("# onNext: {}, {}", tuple.getT1(), tuple.getT2()));
}
~~~

* 20_000_000 보다 큰 값이 나오는 처음이 2017
* 2016 이전까지는 데이터가 출력되고, Predicate 를 평가할때 사용한 데이터 2017 은 출력되지 않음

~~~
10:12:21.589 [main] INFO com.example.test.Example - # onNext: 2010, 565
10:12:21.590 [main] INFO com.example.test.Example - # onNext: 2011, 36094
10:12:21.591 [main] INFO com.example.test.Example - # onNext: 2012, 17425
10:12:21.591 [main] INFO com.example.test.Example - # onNext: 2013, 1405209
10:12:21.591 [main] INFO com.example.test.Example - # onNext: 2014, 1237182
10:12:21.591 [main] INFO com.example.test.Example - # onNext: 2015, 557603
10:12:21.591 [main] INFO com.example.test.Example - # onNext: 2016, 1111811
~~~


### next
* Upstream 에서 emit 되는 데이터중 첫번째 데이터만 Downstream 으로 emit 함
* 만약 Upstream 에서 emit 되는 데이터가 empty 라면 Downstream 으로 empty Mono 를 emit 함

~~~java
public static void main(String[] args) {
    Flux
            .fromIterable(Arrays.asList(
                    Tuples.of(2010, 565L),
                    Tuples.of(2011, 36_094L),
                    Tuples.of(2012, 17_425L),
                    Tuples.of(2013, 1_405_209L),
                    Tuples.of(2014, 1_237_182L),
                    Tuples.of(2015, 557_603L),
                    Tuples.of(2016, 1_111_811L),
                    Tuples.of(2017, 22_483_583L),
                    Tuples.of(2018, 19_521_543L),
                    Tuples.of(2019, 15_761_568L),
                    Tuples.of(2020, 22_439_002L),
                    Tuples.of(2021, 63_364_000L)
            ))
            .next()
            .subscribe(tuple -> log.info("# onNext: {}, {}",  tuple.getT1(), tuple.getT2()));
}
~~~

~~~
10:17:23.658 [main] INFO com.example.test.Example - # onNext: 2010, 565
~~~

## 14.4 Sequence 변환

### map
* Upstream 에서 emit 된 데이터를 mapper Function 을 사용하여 변환한 후, Downstream 으로 emit

#### map sample 1
~~~java
public static void main(String[] args) {
    Flux
        .just("1-Circle", "3-Circle", "5-Circle")
        .map(circle -> circle.replace("Circle", "Rectangle"))
        .subscribe(data -> log.info("# onNext: {}", data));
}
~~~

~~~
10:19:10.818 [main] INFO com.example.test.Example - # onNext: 1-Rectangle
10:19:10.819 [main] INFO com.example.test.Example - # onNext: 3-Rectangle
10:19:10.819 [main] INFO com.example.test.Example - # onNext: 5-Rectangle
~~~

#### map sample 2

~~~java
public class Example {
    public static void main(String[] args) {
        final double buyPrice = 50_000_000;
        Flux
                .fromIterable(SampleData.btcTopPricesPerYear)
                .filter(tuple -> tuple.getT1() == 2021)
                .doOnNext(data -> log.info("# doOnNext: {}", data))
                .map(tuple -> calculateProfitRate(buyPrice, tuple.getT2()))
                .subscribe(data -> log.info("# onNext: {}%", data));
    }

    private static double calculateProfitRate(final double buyPrice, Long topPrice) {
        return (topPrice - buyPrice) / buyPrice * 100;
    }
}
~~~

~~~
10:20:39.693 [main] INFO com.example.test.Example - # doOnNext: [2021,63364000]
10:20:39.695 [main] INFO com.example.test.Example - # onNext: 26.728%
~~~

### flatMap
* Upstream 에서 emit 된 한건의 데이터가 Inner Sequence 에서 여러건의 데이터로 변환됨
* 여러건의 데이터가 flatten 작업과 merge 작업을 거쳐 Downstream 으로 emit

#### flatMap sample 1
~~~java
public static void main(String[] args) {
    Flux
        .just("Good", "Bad")
        .flatMap(feeling -> Flux
                                .just("Morning", "Afternoon", "Evening")
                                .map(time -> feeling + " " + time))
        .subscribe(log::info);
}
~~~

~~~
10:23:35.456 [main] INFO com.example.test.Example - Good Morning
10:23:35.456 [main] INFO com.example.test.Example - Good Afternoon
10:23:35.456 [main] INFO com.example.test.Example - Good Evening
10:23:35.456 [main] INFO com.example.test.Example - Bad Morning
10:23:35.456 [main] INFO com.example.test.Example - Bad Afternoon
10:23:35.456 [main] INFO com.example.test.Example - Bad Evening
~~~

#### flatMap sample 2
* 비동기적으로 데이터를 emit

~~~java
public static void main(String[] args) throws InterruptedException {
    Flux
            .range(2, 8)
            .flatMap(dan -> Flux
                    .range(1, 9)
                    .publishOn(Schedulers.parallel())
                    .map(n -> dan + " * " + n + " = " + dan * n))
            .subscribe(log::info);

    Thread.sleep(100L);
}
~~~

* 3 단 로그를 보면 순서 보장이 되지 않음
~~~
10:26:47.951 [parallel-1] INFO com.example.test.Example - 2 * 1 = 2
...
10:26:47.953 [parallel-1] INFO com.example.test.Example - 2 * 8 = 16
10:26:47.953 [parallel-1] INFO com.example.test.Example - 2 * 9 = 18
10:26:47.956 [parallel-2] INFO com.example.test.Example - 3 * 1 = 3
10:26:47.956 [parallel-2] INFO com.example.test.Example - 4 * 1 = 4
...
10:26:47.956 [parallel-2] INFO com.example.test.Example - 4 * 9 = 36
10:26:47.956 [parallel-2] INFO com.example.test.Example - 5 * 1 = 5
...
10:26:47.956 [parallel-2] INFO com.example.test.Example - 5 * 9 = 45
10:26:47.956 [parallel-2] INFO com.example.test.Example - 6 * 1 = 6
...
10:26:47.956 [parallel-2] INFO com.example.test.Example - 6 * 9 = 54
10:26:47.956 [parallel-2] INFO com.example.test.Example - 7 * 1 = 7
...
10:26:47.956 [parallel-2] INFO com.example.test.Example - 7 * 9 = 63
10:26:47.956 [parallel-2] INFO com.example.test.Example - 8 * 1 = 8
...
10:26:47.957 [parallel-2] INFO com.example.test.Example - 8 * 9 = 72
10:26:47.957 [parallel-2] INFO com.example.test.Example - 9 * 1 = 9
...
10:26:47.957 [parallel-2] INFO com.example.test.Example - 9 * 9 = 81
10:26:47.957 [parallel-2] INFO com.example.test.Example - 3 * 2 = 6
10:26:47.957 [parallel-2] INFO com.example.test.Example - 3 * 3 = 9
10:26:47.957 [parallel-2] INFO com.example.test.Example - 3 * 4 = 12
10:26:47.957 [parallel-2] INFO com.example.test.Example - 3 * 5 = 15
10:26:47.957 [parallel-2] INFO com.example.test.Example - 3 * 6 = 18
10:26:47.957 [parallel-2] INFO com.example.test.Example - 3 * 7 = 21
10:26:47.957 [parallel-2] INFO com.example.test.Example - 3 * 8 = 24
10:26:47.957 [parallel-2] INFO com.example.test.Example - 3 * 9 = 27
~~~

### concat
* 파라미터로 입력되는 Publisher 의 Sequence 를 연결해서 데이터를 순차적으로 emit

#### concat sample 1 

~~~java
public static void main(String[] args) {
    Flux
            .concat(Flux.just(1, 2, 3), Flux.just(4, 5))
            .subscribe(data -> log.info("# onNext: {}", data));
}
~~~

~~~
10:29:23.290 [main] INFO com.example.test.Example - # onNext: 1
10:29:23.292 [main] INFO com.example.test.Example - # onNext: 2
10:29:23.292 [main] INFO com.example.test.Example - # onNext: 3
10:29:23.292 [main] INFO com.example.test.Example - # onNext: 4
10:29:23.292 [main] INFO com.example.test.Example - # onNext: 5
~~~

#### concat sample 2

~~~java
public static void main(String[] args) {
    Flux
            .concat(
                    Flux.fromIterable(Arrays.asList(
                            Tuples.of(CovidVaccine.AstraZeneca, 3_000_000),
                            Tuples.of(CovidVaccine.Janssen, 2_000_000)
                    )),
                    Flux.fromIterable(Arrays.asList(
                            Tuples.of(CovidVaccine.Pfizer, 1_000_000),
                            Tuples.of(CovidVaccine.Moderna, 4_000_000)
                    )),
                    Flux.fromIterable(Arrays.asList(
                            Tuples.of(CovidVaccine.Novavax, 2_500_000)
                    )))
            .subscribe(data -> log.info("# onNext: {}", data));
}
~~~

~~~
10:32:33.404 [main] INFO com.example.test.Example - # onNext: [AstraZeneca,3000000]
10:32:33.406 [main] INFO com.example.test.Example - # onNext: [Janssen,2000000]
10:32:33.406 [main] INFO com.example.test.Example - # onNext: [Pfizer,1000000]
10:32:33.406 [main] INFO com.example.test.Example - # onNext: [Moderna,4000000]
10:32:33.406 [main] INFO com.example.test.Example - # onNext: [Novavax,2500000]
~~~

### merge
* 파라미터로 입력되는 Publisher 의 Sequence 에서 emit 된 데이터를 interleave 방식으로 병합
  * interleave 는 emit 된 시간 순서대로 처리하는 방식
* concat 처럼 하나의 Publisher 의 Sequence 가 종료될때까지 나머지 Publisher 의 Sequence 가 대기하는 것이 아니라, 모든 Publisher 의 Sequence 가 즉시 subscribe 됨

#### merge sample 1

~~~java
public static void main(String[] args) throws InterruptedException {
    Flux
            .merge(
                    Flux.just(1, 2, 3, 4).delayElements(Duration.ofMillis(300L)),
                    Flux.just(5, 6, 7).delayElements(Duration.ofMillis(500L))
            )
            .subscribe(data -> log.info("# onNext: {}", data));

    Thread.sleep(2000L);
}
~~~

* parallel 6개로 실행되었고, onNext 를 보면 순서가 보장되지 않음을 알수 있음

~~~
10:38:06.134 [parallel-1] INFO com.example.test.Example - # onNext: 1
10:38:06.338 [parallel-2] INFO com.example.test.Example - # onNext: 5
10:38:06.443 [parallel-3] INFO com.example.test.Example - # onNext: 2
10:38:06.745 [parallel-5] INFO com.example.test.Example - # onNext: 3
10:38:06.844 [parallel-4] INFO com.example.test.Example - # onNext: 6
10:38:07.051 [parallel-6] INFO com.example.test.Example - # onNext: 4
10:38:07.349 [parallel-7] INFO com.example.test.Example - # onNext: 7
~~~

#### merge sample 2

~~~java
public class Example {
    public static void main(String[] args) throws InterruptedException {
        String[] usaStates = {
                "Ohio", "Michigan", "New Jersey", "Illinois", "New Hampshire",
                "Virginia", "Vermont", "North Carolina", "Ontario", "Georgia"
        };

        Flux
                .merge(getMeltDownRecoveryMessage(usaStates))
                .subscribe(log::info);

        Thread.sleep(2000L);
    }

    public static Map<String, Mono<String>> nppMap = Map.of(
            "Ontario", Mono.just("Ontario Done").delayElement(Duration.ofMillis(1500L)),
            "Vermont", Mono.just("Vermont Done").delayElement(Duration.ofMillis(400L)),
            "New Hampshire", Mono.just("New Hampshire Done").delayElement(Duration.ofMillis(700L)),
            "New Jersey", Mono.just("New Jersey Done").delayElement(Duration.ofMillis(500L)),
            "Ohio", Mono.just("Ohio Done").delayElement(Duration.ofMillis(1000L)),
            "Michigan", Mono.just("Michigan Done").delayElement(Duration.ofMillis(200L)),
            "Illinois", Mono.just("Illinois Done").delayElement(Duration.ofMillis(300L)),
            "Virginia", Mono.just("Virginia Done").delayElement(Duration.ofMillis(600L)),
            "North Carolina", Mono.just("North Carolina Done").delayElement(Duration.ofMillis(800L)),
            "Georgia", Mono.just("Georgia Done").delayElement(Duration.ofMillis(900L))
    );

    private static List<Mono<String>> getMeltDownRecoveryMessage(String[] usaStates) {
        List<Mono<String>> messages = new ArrayList<>();
        for (String state : usaStates) {
            messages.add(SampleData.nppMap.get(state));
        }

        return messages;
    }
}
~~~

~~~
10:44:50.997 [parallel-2] INFO com.example.test.Example - Michigan Done
10:44:51.100 [parallel-4] INFO com.example.test.Example - Illinois Done
10:44:51.200 [parallel-7] INFO com.example.test.Example - Vermont Done
10:44:51.300 [parallel-3] INFO com.example.test.Example - New Jersey Done
10:44:51.400 [parallel-6] INFO com.example.test.Example - Virginia Done
10:44:51.500 [parallel-5] INFO com.example.test.Example - New Hampshire Done
10:44:51.600 [parallel-8] INFO com.example.test.Example - North Carolina Done
10:44:51.698 [parallel-10] INFO com.example.test.Example - Georgia Done
10:44:51.800 [parallel-1] INFO com.example.test.Example - Ohio Done
10:44:52.300 [parallel-9] INFO com.example.test.Example - Ontario Done
~~~

### zip
* 파라미터로 입력되는 Publisher 에서 emit 된 데이터를 결합하는데,
* 각 Publisher  가 데이터를 하나씩 emit 할때까지 기다렸다가 결합

#### zip sample 1
* 0.3, 0.5 초마다 시간이 다르게 emit 하지만, 하나씩 emit 할때까지 기다렸다가 tuple2 객체로 묶어서 Subscriber 에게 전달

~~~java
Flux
    .zip(
        Flux.just(1, 2, 3).delayElements(Duration.ofMillis(300L)),
        Flux.just(4, 5, 6).delayElements(Duration.ofMillis(500L))
    )
    .subscribe(tuple2 -> log.info("# onNext: {}", tuple2));

Thread.sleep(2500L);
~~~

~~~
10:00:34.843 [parallel-2] INFO com.example.test.Example - # onNext: [1,4]
10:00:35.345 [parallel-4] INFO com.example.test.Example - # onNext: [2,5]
10:00:35.848 [parallel-6] INFO com.example.test.Example - # onNext: [3,6]
~~~


#### zip sample 2 - combinator 
* combinator 에서 변환 작업을 거친 후, 최종 변환된 데이터를 Subscriber 에게 전달

~~~java
Flux
    .zip(
        Flux.just(1, 2, 3).delayElements(Duration.ofMillis(300L)),
        Flux.just(4, 5, 6).delayElements(Duration.ofMillis(500L)),
        (n1, n2) -> n1 * n2
    )
    .subscribe(tuple2 -> log.info("# onNext: {}", tuple2));

Thread.sleep(2500L);
~~~

~~~
10:03:13.054 [parallel-2] INFO com.example.test.Example - # onNext: 4
10:03:13.561 [parallel-4] INFO com.example.test.Example - # onNext: 10
10:03:14.064 [parallel-6] INFO com.example.test.Example - # onNext: 18
~~~

### and
* Mono 의 Complete Signal 과 파라미터로 입력된 Publisher 의 Complete Signal 을 결합하여 새로운 Mono<Void> 를 반환
* Mono 와 파라미터로 입력된 Publisher 의 Sequence 가 모두 종료되었음을 Subscriber 에게 알릴수 있음
* 모든 Sequence 가 종료되길 기다렸다가 최종적으로 onComplete Signal 만 전송

#### and sample 1
* 1초에 Task1 emit, 0.6 초 Task2 emit, 1.2 초 Task3 emit
* Upstream 에서 emit 된 데이터가 Subscriber 에 전달되지 않음
  * onNext 로 찍히는 값이 없음
* onComplete 만 로그로 확인

~~~java
Mono
  .just("Task 1")
  .delayElement(Duration.ofSeconds(1))
  .doOnNext(data -> log.info("# Mono doOnNext: {}", data))
  .and(
      Flux
        .just("Task 2", "Task 3")
        .delayElements(Duration.ofMillis(600))
        .doOnNext(data -> log.info("# Flux doOnNext: {}", data))
  )
  .subscribe(
      data -> log.info("# onNext: {}", data),
      error -> log.error("# onError:", error),
      () -> log.info("# onComplete")
  );

Thread.sleep(5000);
~~~

~~~
10:09:15.422 [parallel-2] INFO com.example.test.Example - # Flux doOnNext: Task 2
10:09:15.821 [parallel-1] INFO com.example.test.Example - # Mono doOnNext: Task 1
10:09:16.027 [parallel-3] INFO com.example.test.Example - # Flux doOnNext: Task 3
10:09:16.028 [parallel-3] INFO com.example.test.Example - # onComplete
~~~

#### and sample 2
* restartApplicationServer, restartDBServer 두개 작업이 끝난 시점에 후처리 작업을 수행하는 예제

~~~java
public class Example {
    public static void main(String[] args) throws InterruptedException {
        restartApplicationServer()
                .and(restartDBServer())
                .subscribe(
                        data -> log.info("# onNext: {}", data),
                        error -> log.error("# onError:", error),
                        () -> log.info("# sent an email to Administrator: " +
                                "All Servers are restarted successfully")
                );

        Thread.sleep(6000L);
    }

    private static Mono<String> restartApplicationServer() {
        return Mono
                .just("Application Server was restarted successfully.")
                .delayElement(Duration.ofSeconds(2))
                .doOnNext(log::info);
    }

    private static Publisher<String> restartDBServer() {
        return Mono
                .just("DB Server was restarted successfully.")
                .delayElement(Duration.ofSeconds(4))
                .doOnNext(log::info);
    }
}
~~~

~~~
10:16:25.844 [parallel-1] INFO com.example.test.Example - Application Server was restarted successfully.
10:16:27.838 [parallel-2] INFO com.example.test.Example - DB Server was restarted successfully.
10:16:27.838 [parallel-2] INFO com.example.test.Example - # sent an email to Administrator: All Servers are restarted successfully
~~~

### collectList
* Flux 에서 emit 된 데이터를 모아서 List 로 변환 후, 변환된 List 를 emit 하는 Mono 를 반환
* Upstream Sequence 가 비어 있다면 비어있는 List 를 Downstream 으로 emit

~~~java
public class Example {
    public static void main(String[] args) {
        Flux
                .just("...", "---", "...")
                .map(code -> transformMorseCode(code))
                .collectList()
                .subscribe(list -> log.info(list.stream().collect(Collectors.joining())));
    }

    public static String transformMorseCode(String morseCode) {
        return SampleData.morseCodeMap.get(morseCode);
    }
}
~~~

~~~
10:18:46.289 [main] INFO com.example.test.Example - sos
~~~


### collectMap
* Flux 에서 emit 된 데이터를 기반으로 key 와 value 를 생성하여 Map 의 Element 로 추가한후, 최종적으로 Map 을 emit 하는 Mono 를 반환

~~~java
public class Example {
    public static void main(String[] args) {
        Flux
                .range(0, 26)
                .collectMap(key -> SampleData.morseCodes[key],
                        value -> transformToLetter(value))
                .subscribe(map -> log.info("# onNext: {}", map));
    }

    private static String transformToLetter(int value) {
        return Character.toString((char) ('a' + value));
    }
}
~~~

~~~
# onNext: {..=i, .---=j, --.-=q, ---=o, --.=g, .--=w, .-.=r, -.--=y, ....=h, -.-.=c, --=m, -.=n, .-..=l, ...-=v, -.-=k, -..=d, -=t, ..-=u, .=e, ...=s, -...=b, ..-.=f, .--.=p, -..-=x, --..=z, .-=a}
~~~

## 14.5 Sequence 의 내부 동작 확인을 위한 Operator
* Reactor 에서 Upstream Publisher 에서 emit 되는 데이터의 변경 없이 side effect 만을 수행하기 위한 Operator
* doOnXXX() 로 시작하는 Operator 임
* doOnXXX 로 시작하는 Operator 는 Consumer 또는 Runnable 타입의 함수형 인터페이스를 파라미터로 가지기 때문에 별도의 리턴 값이 없음
* Publisher 의 내부 동작을 엿볼 수 있으며, 로그를 출력하는 등의 디버깅 용도로 많이 사용

### doOnSubscriber
### doOnRequest
### doOnNext
### doOnComplete
### doOnError
### doOnCancel
### doOnTerminate
### doOnEach
### doOnDiscard
### doAfterTerminate
### doFirst
* 위치와 상관없이 제일 먼저 동작
### doFinally
* 위치와 상관없이 제일 마지막에 동작

~~~java
Flux.range(1, 5)
    .doFinally(signalType -> log.info("# doFinally 1: {}", signalType))
    .doFinally(signalType -> log.info("# doFinally 2: {}", signalType))
    .doOnNext(data -> log.info("# range > doOnNext(): {}", data))
    .doOnRequest(data -> log.info("# doOnRequest: {}", data))
    .doOnSubscribe(subscription -> log.info("# doOnSubscribe 1"))
    .doFirst(() -> log.info("# doFirst()"))
    .filter(num -> num % 2 == 1)
    .doOnNext(data -> log.info("# filter > doOnNext(): {}", data))
    .doOnComplete(() -> log.info("# doOnComplete()"))
    .subscribe(new BaseSubscriber<Integer>() {
        @Override
        protected void hookOnSubscribe(Subscription subscription) {
            request(1);
        }

        @Override
        protected void hookOnNext(Integer value) {
            log.info("# hookOnNext: {}", value);
            request(1);
        }
    });
~~~

~~~
10:28:48.129 [main] INFO com.example.test.Example - # doFirst()
10:28:48.131 [main] INFO com.example.test.Example - # doOnSubscribe 1
10:28:48.131 [main] INFO com.example.test.Example - # doOnRequest: 1
10:28:48.131 [main] INFO com.example.test.Example - # range > doOnNext(): 1
10:28:48.131 [main] INFO com.example.test.Example - # filter > doOnNext(): 1
10:28:48.131 [main] INFO com.example.test.Example - # hookOnNext: 1
10:28:48.131 [main] INFO com.example.test.Example - # doOnRequest: 1
10:28:48.131 [main] INFO com.example.test.Example - # range > doOnNext(): 2
10:28:48.132 [main] INFO com.example.test.Example - # range > doOnNext(): 3
10:28:48.132 [main] INFO com.example.test.Example - # filter > doOnNext(): 3
10:28:48.132 [main] INFO com.example.test.Example - # hookOnNext: 3
10:28:48.132 [main] INFO com.example.test.Example - # doOnRequest: 1
10:28:48.132 [main] INFO com.example.test.Example - # range > doOnNext(): 4
10:28:48.132 [main] INFO com.example.test.Example - # range > doOnNext(): 5
10:28:48.132 [main] INFO com.example.test.Example - # filter > doOnNext(): 5
10:28:48.132 [main] INFO com.example.test.Example - # hookOnNext: 5
10:28:48.132 [main] INFO com.example.test.Example - # doOnRequest: 1
10:28:48.132 [main] INFO com.example.test.Example - # doOnComplete()
10:28:48.132 [main] INFO com.example.test.Example - # doFinally 2: onComplete
10:28:48.132 [main] INFO com.example.test.Example - # doFinally 1: onComplete
~~~


## 14.6 에러 처리를 위한 Operator

### error
* 파라미터로 지정된 에러로 종료하는 Flux 를 생성
* throw 키워드를 사용해서 예외를 의도적으로 던지는것 같은 역할

#### error sample 1
* 명시적으로 error 이벤트를 발생시켜야 하는 경우

~~~java
Flux
  .range(1, 5)
  .flatMap(num -> {
      if ((num * 2) % 3 == 0) {
          return Flux.error(new IllegalArgumentException("Not allowed multiple of 3"));
      } else {
          return Mono.just(num * 2);
      }
  })
  .subscribe(data -> log.info("# onNext: {}", data),
          error -> log.error("# onError: ", error));
~~~

~~~
10:35:19.263 [main] INFO com.example.test.Example - # onNext: 2
10:35:19.263 [main] INFO com.example.test.Example - # onNext: 4
10:35:19.265 [main] ERROR com.example.test.Example - # onError: 
java.lang.IllegalArgumentException: Not allowed multiple of 3
	at com.example.test.Example.lambda$main$0(Example.java:28)
	at com.example.test.Example.main(Example.java:33)
~~~


#### error sample 2
* flatMap 처럼 Inner Sequence 가 존재하는 경우 체크 예외 발생 시 Flux 로 래핑해서 onError Signal 을 전송할 수 있다.

~~~java
public class Example {
    public static void main(String[] args) {
        Flux
                .just('a', 'b', 'c', '3', 'd')
                .flatMap(letter -> {
                    try {
                        return convert(letter);
                    } catch (DataFormatException e) {
                        return Flux.error(e);
                    }
                })
                .subscribe(data -> log.info("# onNext: {}", data),
                        error -> log.error("# onError: ", error));
    }

    private static Mono<String> convert(char ch) throws DataFormatException {
        if (!Character.isAlphabetic(ch)) {
            throw new DataFormatException("Not Alphabetic");
        }
        return Mono.just("Converted to " + Character.toUpperCase(ch));
    }
}
~~~

~~~
10:37:38.633 [main] INFO com.example.test.Example - # onNext: Converted to A
10:37:38.633 [main] INFO com.example.test.Example - # onNext: Converted to B
10:37:38.633 [main] INFO com.example.test.Example - # onNext: Converted to C
10:37:38.635 [main] ERROR com.example.test.Example - # onError: 
java.util.zip.DataFormatException: Not Alphabetic
	at com.example.test.Example.convert(Example.java:40)
	at com.example.test.Example.lambda$main$0(Example.java:29)
	at com.example.test.Example.main(Example.java:34)
~~~

### onErrorReturn
* 예외가 발생했을 때, error 이벤트를 발생시키지 않고, 대체값을 emit 함
* try ~ catch 문의 경우, catch해서 return default value 하는 것과 같다.

#### onErrorReturn sample 1

~~~java
public class Example {
    public static void main(String[] args) {
        getBooks()
                .map(book -> book.getPenName().toUpperCase())
                .onErrorReturn("No pen name")
                .subscribe(log::info);
    }

    public static Flux<Book> getBooks() {
        return Flux.fromIterable(Arrays.asList(
                new Book("Advance Java", "Tom", "Tom-boy", 25000, 100),
                new Book("Advance Python", "Grace", "Grace-girl", 22000, 150),
                new Book("Advance Reactor", "Smith", "David-boy", 35000, 200),
                new Book("Getting started Java", "Tom", "Tom-boy", 32000, 230),
                new Book("Advance Kotlin", "Kevin", "Kevin-boy", 32000, 250),
                new Book("Advance Javascript", "Mike", "Tom-boy", 32000, 320),
                new Book("Getting started Kotlin", "Kevin", "Kevin-boy", 32000, 150),
                new Book("Getting started Python", "Grace", "Grace-girl", 32000, 200),
                new Book("Getting started Reactor", "Smith", null, 32000, 250),
                new Book("Getting started Javascript", "Mike", "David-boy", 32000, 330)
        ));
    }
    
    @Getter
    @AllArgsConstructor
    public static class Book {
        private String bookName;
        private String authorName;
        private String penName;
        private int price;
        private int stockQuantity;
    }
}
~~~

~~~
10:38:44.384 [main] INFO com.example.test.Example - TOM-BOY
10:38:44.384 [main] INFO com.example.test.Example - GRACE-GIRL
10:38:44.384 [main] INFO com.example.test.Example - DAVID-BOY
10:38:44.384 [main] INFO com.example.test.Example - TOM-BOY
10:38:44.384 [main] INFO com.example.test.Example - KEVIN-BOY
10:38:44.384 [main] INFO com.example.test.Example - TOM-BOY
10:38:44.384 [main] INFO com.example.test.Example - KEVIN-BOY
10:38:44.384 [main] INFO com.example.test.Example - GRACE-GIRL
10:38:44.385 [main] INFO com.example.test.Example - No pen name
~~~

#### onErrorReturn sample 2
* 첫번째 파라미터로 특정 예외 타입을 지정해서 지정된 타입의 예외가 발생할 경우에만 대체값을 emit 하도록 함

~~~
public class Example {
    public static void main(String[] args) {
        getBooks()
                .map(book -> book.getPenName().toUpperCase())
                .onErrorReturn(NullPointerException.class, "no pen name")
                .onErrorReturn(IllegalFormatException.class, "Illegal pen name")
                .subscribe(log::info);
    }
}
~~~


### onErrorResume
* 에러 이벤트가 발생했을 때, 에러 이벤트를 Downstream 으로 전파하지 않고 대체 Publisher 를 리턴
* onErrorResume 에서 새로운 Publisher 로 리턴됨

~~~java
public class Example {
    public static void main(String[] args) {
        final String keyword = "DDD";
        getBooksFromCache(keyword)
                .onErrorResume(error -> getBooksFromDatabase(keyword))
                .subscribe(data -> log.info("# onNext: {}", data.getBookName()),
                        error -> log.error("# onError: ", error));
    }

    public static Flux<Book> getBooksFromCache(final String keyword) {
        return Flux
                .fromIterable(SampleData.books)
                .filter(book -> book.getBookName().contains(keyword))
                .switchIfEmpty(Flux.error(new NoSuchBookException("No such Book")));
    }

    public static Flux<Book> getBooksFromDatabase(final String keyword) {
        List<Book> books = new ArrayList<>(SampleData.books);
        books.add(new Book("DDD: Domain Driven Design",
                "Joy", "ddd-man", 35000, 200));
        return Flux
                .fromIterable(books)
                .filter(book -> book.getBookName().contains(keyword))
                .switchIfEmpty(Flux.error(new NoSuchBookException("No such Book")));
    }

    private static class NoSuchBookException extends RuntimeException {
        NoSuchBookException(String message) {
            super(message);
        }
    }
}
~~~

~~~
10:47:04.585 [main] INFO com.example.test.Example - # onNext: DDD: Domain Driven Design
~~~

### onErrorContinue
* 에러가 발생했을때, Sequence 가 종료되지 않고, 아직 emit 되지 않은 데이터를 다시 emit 해야하는 상황에 사용
* 에러 영역 내에 있는 데이터는 제거하고, Upstream 에서 후속 데이터를 emit 하는 방식으로 에러를 복구할수 있도록 해줌

~~~java
public static void main(String[] args) {
    Flux
            .just(1, 2, 4, 0, 6, 12)
            .map(num -> 12 / num)
            .onErrorContinue((error, num) -> log.error("error: {}, num: {}", error, num))
            .subscribe(data -> log.info("# onNext: {}", data),
                    error -> log.error("# onError: ", error));
}
~~~

~~~
10:51:53.993 [main] INFO com.example.test.Example - # onNext: 12
10:51:53.994 [main] INFO com.example.test.Example - # onNext: 6
10:51:53.994 [main] INFO com.example.test.Example - # onNext: 3
10:51:53.995 [main] ERROR com.example.test.Example - error: java.lang.ArithmeticException: / by zero, num: 0
10:51:53.995 [main] INFO com.example.test.Example - # onNext: 2
10:51:53.995 [main] INFO com.example.test.Example - # onNext: 1
~~~

### retry
* Publisher 가 데이터를 emit 하는 과정에서 에러가 발생하면, 파라미터로 입력한 횟수만큼 원본 Flux 의 Sequence 를 다시 구독
* 파라미터로 Long.MAX_VALUE 를 입력하면 재구독을 무한 반복함

#### retry sample 1

~~~java
public static void main(String[] args) throws InterruptedException {
    final int[] count = {1};
    Flux
        .range(1, 3)
        .delayElements(Duration.ofSeconds(1))
        .map(num -> {
            try {
                if (num == 3 && count[0] == 1) {
                    count[0]++;
                    Thread.sleep(1000);
                }
            } catch (InterruptedException e) {}

            return num;
        })
        .timeout(Duration.ofMillis(1500))
        .retry(1)
        .subscribe(data -> log.info("# onNext: {}", data),
                (error -> log.error("# onError: ", error)),
                () -> log.info("# onComplete"));

    Thread.sleep(7000);
}
~~~

~~~
10:53:48.898 [parallel-2] INFO com.example.test.Example - # onNext: 1
10:53:49.904 [parallel-4] INFO com.example.test.Example - # onNext: 2
10:53:51.911 [parallel-6] DEBUG reactor.core.publisher.Operators - onNextDropped: 3
10:53:52.418 [parallel-8] INFO com.example.test.Example - # onNext: 1
10:53:53.425 [parallel-10] INFO com.example.test.Example - # onNext: 2
10:53:54.430 [parallel-2] INFO com.example.test.Example - # onNext: 3
10:53:54.430 [parallel-2] INFO com.example.test.Example - # onComplete
~~~

#### retry sample 2
* .collect(Collectors.toSet()) 중복을 없애려고 toSet 을 사용
~~~java
public class Example {
    public static void main(String[] args) throws InterruptedException {
        getBooks()
                .collect(Collectors.toSet())
                .subscribe(bookSet -> bookSet.stream()
                        .forEach(book -> log.info("book name: {}, price: {}",
                                book.getBookName(), book.getPrice())));

        Thread.sleep(12000);
    }

    private static Flux<Book> getBooks() {
        final int[] count = {0};
        return Flux
                .fromIterable(SampleData.books)
                .delayElements(Duration.ofMillis(500))
                .map(book -> {
                    try {
                        count[0]++;
                        if (count[0] == 3) {
                            Thread.sleep(2000);
                        }
                    } catch (InterruptedException e) {
                    }

                    return book;
                })
                .timeout(Duration.ofSeconds(2))
                .retry(1)
                .doOnNext(book -> log.info("# getBooks > doOnNext: {}, price: {}",
                        book.getBookName(), book.getPrice()));
    }
}
~~~

~~~
10:56:32.253 [parallel-2] INFO com.example.test.Example - # getBooks > doOnNext: Advance Java, price: 25000
10:56:32.757 [parallel-4] INFO com.example.test.Example - # getBooks > doOnNext: Advance Python, price: 22000
10:56:35.259 [parallel-8] INFO com.example.test.Example - # getBooks > doOnNext: Advance Java, price: 25000
10:56:35.267 [parallel-6] DEBUG reactor.core.publisher.Operators - onNextDropped: com.example.test.Book@6464503f
10:56:35.765 [parallel-10] INFO com.example.test.Example - # getBooks > doOnNext: Advance Python, price: 22000
10:56:36.271 [parallel-2] INFO com.example.test.Example - # getBooks > doOnNext: Advance Reactor, price: 35000
10:56:36.776 [parallel-4] INFO com.example.test.Example - # getBooks > doOnNext: Getting started Java, price: 32000
10:56:37.282 [parallel-6] INFO com.example.test.Example - # getBooks > doOnNext: Advance Kotlin, price: 32000
10:56:37.793 [parallel-8] INFO com.example.test.Example - # getBooks > doOnNext: Advance Javascript, price: 32000
10:56:38.301 [parallel-10] INFO com.example.test.Example - # getBooks > doOnNext: Getting started Kotlin, price: 32000
10:56:38.804 [parallel-2] INFO com.example.test.Example - # getBooks > doOnNext: Getting started Python, price: 32000
10:56:39.309 [parallel-4] INFO com.example.test.Example - # getBooks > doOnNext: Getting started Reactor, price: 32000
10:56:39.811 [parallel-6] INFO com.example.test.Example - # getBooks > doOnNext: Getting started Javascript, price: 32000
10:56:39.814 [parallel-6] INFO com.example.test.Example - book name: Advance Kotlin, price: 32000
10:56:39.814 [parallel-6] INFO com.example.test.Example - book name: Getting started Javascript, price: 32000
10:56:39.814 [parallel-6] INFO com.example.test.Example - book name: Advance Javascript, price: 32000
10:56:39.814 [parallel-6] INFO com.example.test.Example - book name: Advance Python, price: 22000
10:56:39.814 [parallel-6] INFO com.example.test.Example - book name: Getting started Python, price: 32000
10:56:39.815 [parallel-6] INFO com.example.test.Example - book name: Getting started Kotlin, price: 32000
10:56:39.816 [parallel-6] INFO com.example.test.Example - book name: Getting started Java, price: 32000
10:56:39.816 [parallel-6] INFO com.example.test.Example - book name: Advance Java, price: 25000
10:56:39.816 [parallel-6] INFO com.example.test.Example - book name: Advance Reactor, price: 35000
10:56:39.816 [parallel-6] INFO com.example.test.Example - book name: Getting started Reactor, price: 32000
~~~

## 14.7 Sequence 의 동작 시간 측정을 위한 Operator

### elapsed
* `emit 된 데이터 사이의 경과 시간`을 측정해서 Tuple<Long, T> 형태로 Downstream 에 emit

#### elapsed sample 1
* emit 된 첫번째 데이터는 onSubscribe Signal 과 첫번째 데이터 사이의 시간을 기준으로 측정

~~~java
public static void main(String[] args) throws InterruptedException {
    Flux
            .range(1, 5)
            .delayElements(Duration.ofSeconds(1))
            .elapsed()
            .subscribe(data -> log.info("# onNext: {}, time: {}",
                    data.getT2(), data.getT1()));

    Thread.sleep(6000);
}
~~~

~~~
10:58:48.626 [parallel-1] INFO com.example.test.Example - # onNext: 1, time: 1014
10:58:49.627 [parallel-2] INFO com.example.test.Example - # onNext: 2, time: 1002
10:58:50.632 [parallel-3] INFO com.example.test.Example - # onNext: 3, time: 1005
10:58:51.638 [parallel-4] INFO com.example.test.Example - # onNext: 4, time: 1006
10:58:52.641 [parallel-5] INFO com.example.test.Example - # onNext: 5, time: 1003
~~~

#### elapsed sample 2

~~~java
public static void main(String[] args) {
    URI worldTimeUri = UriComponentsBuilder.newInstance().scheme("http")
            .host("worldtimeapi.org")
            .port(80)
            .path("/api/timezone/Asia/Seoul")
            .build()
            .encode()
            .toUri();

    RestTemplate restTemplate = new RestTemplate();
    HttpHeaders headers = new HttpHeaders();
    headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));


    Mono.defer(() -> Mono.just(
                            restTemplate
                                    .exchange(worldTimeUri,
                                            HttpMethod.GET,
                                            new HttpEntity<String>(headers),
                                            String.class)
                    )
            )
            .repeat(4)
            .elapsed()
            .map(response -> {
                DocumentContext jsonContext =
                        JsonPath.parse(response.getT2().getBody());
                String dateTime = jsonContext.read("$.datetime");
                return Tuples.of(dateTime, response.getT1());
            })
            .subscribe(
                    data -> log.info("now: {}, elapsed time: {}", data.getT1(), data.getT2()),
                    error -> log.error("# onError:", error),
                    () -> log.info("# onComplete")
            );
}
~~~

~~~
11:01:29.456 [main] DEBUG org.springframework.web.client.RestTemplate - HTTP GET http://worldtimeapi.org:80/api/timezone/Asia/Seoul
11:01:29.855 [main] INFO com.example.test.Example - now: 2024-04-11T11:01:29.767723+09:00, elapsed time: 381
11:01:29.855 [main] DEBUG org.springframework.web.client.RestTemplate - HTTP GET http://worldtimeapi.org:80/api/timezone/Asia/Seoul
11:01:29.973 [main] INFO com.example.test.Example - now: 2024-04-11T11:01:29.905697+09:00, elapsed time: 141
11:01:29.973 [main] DEBUG org.springframework.web.client.RestTemplate - HTTP GET http://worldtimeapi.org:80/api/timezone/Asia/Seoul
11:01:30.069 [main] INFO com.example.test.Example - now: 2024-04-11T11:01:30.026461+09:00, elapsed time: 97
11:01:30.069 [main] DEBUG org.springframework.web.client.RestTemplate - HTTP GET http://worldtimeapi.org:80/api/timezone/Asia/Seoul
11:01:30.165 [main] INFO com.example.test.Example - now: 2024-04-11T11:01:30.119298+09:00, elapsed time: 96
11:01:30.165 [main] DEBUG org.springframework.web.client.RestTemplate - HTTP GET http://worldtimeapi.org:80/api/timezone/Asia/Seoul
11:01:30.258 [main] INFO com.example.test.Example - now: 2024-04-11T11:01:30.216329+09:00, elapsed time: 93
11:01:30.261 [main] INFO com.example.test.Example - # onComplete
~~~

## 14.8 Flux Sequence 분할을 위한 Operator

### window(maxSize)
* Upstream에서 emit되는 첫 번째 데이터부터 maxSize의 숫자만큼의 데이터를 포함하는 새로운 Flux로 분할함
* 새롭게 생성되는 Flux를 윈도우(Window)라고 함

~~~java
public static void main(String[] args) {
    Flux.range(1, 11)
            .window(3)
            .flatMap(flux -> {
                log.info("======================");
                return flux;
            })
            .subscribe(new BaseSubscriber<Integer>() {
                @Override
                protected void hookOnSubscribe(Subscription subscription) {
                    subscription.request(2);
                }

                @Override
                protected void hookOnNext(Integer value) {
                    log.info("# onNext: {}", value);
                    request(2);
                }
            });
}
~~~

~~~
11:05:29.559 [main] INFO com.example.test.Example - ======================
11:05:29.560 [main] INFO com.example.test.Example - # onNext: 1
11:05:29.561 [main] INFO com.example.test.Example - # onNext: 2
11:05:29.561 [main] INFO com.example.test.Example - # onNext: 3
11:05:29.561 [main] INFO com.example.test.Example - ======================
11:05:29.561 [main] INFO com.example.test.Example - # onNext: 4
11:05:29.561 [main] INFO com.example.test.Example - # onNext: 5
11:05:29.561 [main] INFO com.example.test.Example - # onNext: 6
11:05:29.561 [main] INFO com.example.test.Example - ======================
11:05:29.561 [main] INFO com.example.test.Example - # onNext: 7
11:05:29.561 [main] INFO com.example.test.Example - # onNext: 8
11:05:29.561 [main] INFO com.example.test.Example - # onNext: 9
11:05:29.561 [main] INFO com.example.test.Example - ======================
11:05:29.561 [main] INFO com.example.test.Example - # onNext: 10
11:05:29.561 [main] INFO com.example.test.Example - # onNext: 11
~~~

### buffer(maxSize)
* Upstream에서 emit되는 첫 번째 데이터부터 maxSize 숫자만큼의 데이터를 List 버퍼로 한번에 emit

~~~java
public static void main(String[] args) {
    Flux.range(1, 95)
            .buffer(10)
            .subscribe(buffer -> log.info("# onNext: {}", buffer));
}
~~~

~~~
11:07:45.290 [main] INFO com.example.test.Example - # onNext: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
11:07:45.290 [main] INFO com.example.test.Example - # onNext: [11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
11:07:45.290 [main] INFO com.example.test.Example - # onNext: [21, 22, 23, 24, 25, 26, 27, 28, 29, 30]
11:07:45.290 [main] INFO com.example.test.Example - # onNext: [31, 32, 33, 34, 35, 36, 37, 38, 39, 40]
11:07:45.290 [main] INFO com.example.test.Example - # onNext: [41, 42, 43, 44, 45, 46, 47, 48, 49, 50]
11:07:45.290 [main] INFO com.example.test.Example - # onNext: [51, 52, 53, 54, 55, 56, 57, 58, 59, 60]
11:07:45.290 [main] INFO com.example.test.Example - # onNext: [61, 62, 63, 64, 65, 66, 67, 68, 69, 70]
11:07:45.290 [main] INFO com.example.test.Example - # onNext: [71, 72, 73, 74, 75, 76, 77, 78, 79, 80]
11:07:45.290 [main] INFO com.example.test.Example - # onNext: [81, 82, 83, 84, 85, 86, 87, 88, 89, 90]
11:07:45.290 [main] INFO com.example.test.Example - # onNext: [91, 92, 93, 94, 95]
~~~

### bufferTimeout(maxSize, maxTime)
* Upstream에서 emit되는 첫 번째 데이터부터 maxSize 숫자 만큼의 데이터 또는 maxTime 내에 emit된 데이터를 List 버퍼로 한번에 emit
* maxSize나 maxTime에서 먼저 조건에 부합할때까지 emit된 데이터를 List 버퍼로 emit 

~~~java
public static void main(String[] args) {
    Flux
        .range(1, 20)
        .map(num -> {
            try {
                if (num < 10) {
                    Thread.sleep(100L);
                } else {
                    Thread.sleep(300L);
                }
            } catch (InterruptedException e) {}
            return num;
        })
        .bufferTimeout(3, Duration.ofMillis(400L))
        .subscribe(buffer -> log.info("# onNext: {}", buffer));
}
~~~

~~~
11:09:00.156 [main] INFO com.example.test.Example - # onNext: [1, 2, 3]
11:09:00.469 [main] INFO com.example.test.Example - # onNext: [4, 5, 6]
11:09:00.777 [main] INFO com.example.test.Example - # onNext: [7, 8, 9]
11:09:01.483 [parallel-1] INFO com.example.test.Example - # onNext: [10, 11]
11:09:02.091 [parallel-1] INFO com.example.test.Example - # onNext: [12, 13]
11:09:02.700 [parallel-1] INFO com.example.test.Example - # onNext: [14, 15]
11:09:03.307 [parallel-1] INFO com.example.test.Example - # onNext: [16, 17]
11:09:03.919 [parallel-1] INFO com.example.test.Example - # onNext: [18, 19]
11:09:04.118 [main] INFO com.example.test.Example - # onNext: [20]
~~~

### groupBy(keyMapper)
* emit되는 데이터를 key를 기준으로 그룹화 한 GroupedFlux 를 리턴
* 그룹화 된 GroupedFlux로 그룹별 작업을 할 수 있음

### groupBy(keyMapper) sample 1

~~~java
public static void main(String[] args) {
    Flux.fromIterable(SampleData.books)
            .groupBy(book -> book.getAuthorName())
            .flatMap(groupedFlux ->
                    groupedFlux
                            .map(book -> book.getBookName() + "(" + book.getAuthorName() + ")")
                            .collectList()
            )
            .subscribe(bookByAuthor -> log.info("# book by author: {}", bookByAuthor));
}
~~~

~~~
# book by author: [Advance Kotlin(Kevin), Getting started Kotlin(Kevin)]
# book by author: [Advance Javascript(Mike), Getting started Javascript(Mike)]
# book by author: [Advance Java(Tom), Getting started Java(Tom)]
# book by author: [Advance Python(Grace), Getting started Python(Grace)]
# book by author: [Advance Reactor(Smith), Getting started Reactor(Smith)]
~~~

### groupBy(keyMapper) sample 2
* valueMapper를 추가로 전달해서 그룹화 되어 emit되는 데이터의 값을 미리 다른 값으로 변경할 수 있음

~~~java
public static void main(String[] args) {
    Flux.fromIterable(SampleData.books)
            .groupBy(book -> book.getAuthorName(),
                    book -> book.getBookName() + "(" + book.getAuthorName() + ")")
            .flatMap(groupedFlux -> groupedFlux.collectList())
            .subscribe(bookByAuthor -> log.info("# book by author: {}", bookByAuthor));
}
~~~

~~~
# book by author: [Advance Kotlin(Kevin), Getting started Kotlin(Kevin)]
# book by author: [Advance Javascript(Mike), Getting started Javascript(Mike)]
# book by author: [Advance Java(Tom), Getting started Java(Tom)]
# book by author: [Advance Python(Grace), Getting started Python(Grace)]
# book by author: [Advance Reactor(Smith), Getting started Reactor(Smith)]
~~~

### groupBy(keyMapper) sample 3
* 그룹화 된 GroupedFlux로 그룹별 작업을 할 수 있다.
* 저자 명으로 된 도서의 가격

~~~java
public static void main(String[] args) {
    Flux.fromIterable(SampleData.books)
      .groupBy(book -> book.getAuthorName())
      .flatMap(groupedFlux -> 
        Mono
          .just(groupedFlux.key())
          .zipWith(
              groupedFlux
                      .map(book -> (int)(book.getPrice() * book.getStockQuantity() * 0.1))
                      .reduce((y1, y2) -> y1 + y2),
              (authorName, sumRoyalty) -> authorName + "'s royalty: " + sumRoyalty)
      )
      .subscribe(log::info);
}
~~~

~~~
11:18:48.219 [main] INFO com.example.test.Example - Kevin's royalty: 1280000
11:18:48.219 [main] INFO com.example.test.Example - Mike's royalty: 2080000
11:18:48.219 [main] INFO com.example.test.Example - Tom's royalty: 986000
11:18:48.219 [main] INFO com.example.test.Example - Grace's royalty: 970000
11:18:48.219 [main] INFO com.example.test.Example - Smith's royalty: 1500000
~~~

## 14.9 다수의 Subscriber 에게 Flux 를 멀티캐스팅하기 위한 Operator
* Subscriber 가 구독을 하면 Upstream 에서 emit 된 데이터가 구독중인 모든 Subscriber 에게 멀티캐스팅 되는데,
* 이를 가능하게 해주는 Operator 들은 Cold Sequence 를 Hot Sequence 로 동작하게 하는 특징이 있음

### publish
* 구독을 하더라도 구독 시점에 즉시 데이터를 emit 하지 않고, connect 를 호출하는 시점에 데이터를 emit
* 다수의 Subscriber와 Flux를 공유함
* 즉, Cold Sequence를 Hot Sequence로 변환

#### publish sample 1
* subscriber1, subscriber2 모두 전달 받음
* subscriber3 은 4,5 만 받음

~~~java
public static void main(String[] args) throws InterruptedException {
    ConnectableFlux<Integer> flux =
            Flux
                    .range(1, 5)
                    .delayElements(Duration.ofMillis(300L))
                    .publish();

    Thread.sleep(500L);
    flux.subscribe(data -> log.info("# subscriber1: {}", data));

    Thread.sleep(200L);
    flux.subscribe(data -> log.info("# subscriber2: {}", data));

    flux.connect();

    Thread.sleep(1000L);
    flux.subscribe(data -> log.info("# subscriber3: {}", data));

    Thread.sleep(2000L);
}
~~~

~~~
11:24:59.625 [parallel-1] INFO com.example.test.Example - # subscriber1: 1
11:24:59.626 [parallel-1] INFO com.example.test.Example - # subscriber2: 1
11:24:59.931 [parallel-2] INFO com.example.test.Example - # subscriber1: 2
11:24:59.931 [parallel-2] INFO com.example.test.Example - # subscriber2: 2
11:25:00.237 [parallel-3] INFO com.example.test.Example - # subscriber1: 3
11:25:00.237 [parallel-3] INFO com.example.test.Example - # subscriber2: 3
11:25:00.538 [parallel-4] INFO com.example.test.Example - # subscriber1: 4
11:25:00.538 [parallel-4] INFO com.example.test.Example - # subscriber2: 4
11:25:00.538 [parallel-4] INFO com.example.test.Example - # subscriber3: 4
11:25:00.843 [parallel-5] INFO com.example.test.Example - # subscriber1: 5
11:25:00.843 [parallel-5] INFO com.example.test.Example - # subscriber2: 5
11:25:00.843 [parallel-5] INFO com.example.test.Example - # subscriber3: 5
~~~

#### publish sample 2

~~~java
public class Example {
    private static ConnectableFlux<String> publisher;
    private static int checkedAudience;
    static {
        publisher =
                Flux
                        .just("Concert part1", "Concert part2", "Concert part3")
                        .delayElements(Duration.ofMillis(300L))
                        .publish();
    }

    public static void main(String[] args) throws InterruptedException {
        checkAudience();
        Thread.sleep(500L);
        publisher.subscribe(data -> log.info("# audience 1 is watching {}", data));
        checkedAudience++;

        Thread.sleep(500L);
        publisher.subscribe(data -> log.info("# audience 2 is watching {}", data));
        checkedAudience++;

        checkAudience();

        Thread.sleep(500L);
        publisher.subscribe(data -> log.info("# audience 3 is watching {}", data));

        Thread.sleep(1000L);
    }

    public static void checkAudience() {
        if (checkedAudience >= 2) {
            publisher.connect();
        }
    }
}
~~~

~~~
11:29:27.300 [parallel-1] INFO com.example.test.Example - # audience 1 is watching Concert part1
11:29:27.301 [parallel-1] INFO com.example.test.Example - # audience 2 is watching Concert part1
11:29:27.613 [parallel-2] INFO com.example.test.Example - # audience 1 is watching Concert part2
11:29:27.613 [parallel-2] INFO com.example.test.Example - # audience 2 is watching Concert part2
11:29:27.613 [parallel-2] INFO com.example.test.Example - # audience 3 is watching Concert part2
11:29:27.918 [parallel-3] INFO com.example.test.Example - # audience 1 is watching Concert part3
11:29:27.918 [parallel-3] INFO com.example.test.Example - # audience 2 is watching Concert part3
11:29:27.918 [parallel-3] INFO com.example.test.Example - # audience 3 is watching Concert part3
~~~

### autoConnect
* publish() 는 구독이 발생하더라도 connect() 를 호출하기전까지는 데이터를 emit 하지 않기 때문에 코드상에서 connect() 를 직접 호출해야함
* 반면에 autoConnect 는 파라미터로 지정하는 숮자만큼의 구독이 발생하는 시점에 Upstream 소스에 자동으로 연결이 되기 때문에, 별도의 connect() 호출이 필요 없음

#### autoConnect sample 1

~~~java
public static void main(String[] args) throws InterruptedException {
    Flux<String> publisher =
            Flux
                    .just("Concert part1", "Concert part2", "Concert part3")
                    .delayElements(Duration.ofMillis(300L))
                    .publish()
                    .autoConnect(2);

    Thread.sleep(500L);
    publisher.subscribe(data -> log.info("# audience 1 is watching {}", data));

    Thread.sleep(500L);
    publisher.subscribe(data -> log.info("# audience 2 is watching {}", data));

    Thread.sleep(500L);
    publisher.subscribe(data -> log.info("# audience 3 is watching {}", data));

    Thread.sleep(1000L);
}
~~~

~~~
11:33:30.398 [parallel-1] INFO com.example.test.Example - # audience 1 is watching Concert part1
11:33:30.399 [parallel-1] INFO com.example.test.Example - # audience 2 is watching Concert part1
11:33:30.705 [parallel-2] INFO com.example.test.Example - # audience 1 is watching Concert part2
11:33:30.705 [parallel-2] INFO com.example.test.Example - # audience 2 is watching Concert part2
11:33:30.705 [parallel-2] INFO com.example.test.Example - # audience 3 is watching Concert part2
11:33:31.010 [parallel-3] INFO com.example.test.Example - # audience 1 is watching Concert part3
11:33:31.010 [parallel-3] INFO com.example.test.Example - # audience 2 is watching Concert part3
11:33:31.010 [parallel-3] INFO com.example.test.Example - # audience 3 is watching Concert 
~~~



### refCount
* 파라미터로 입력된 숫자만큼의 구독이 발생하는 시점에 Upstream 소스에 연결되며, 모든 구독이 취소되거나 Upstream 의 데이터 emit 이 종료되면 연결이 해체됨
* 무한 스트림 상황에서 모든 구독이 취소될 경우 연결을 해제하는데 사용할수 있음

#### refCount sample 1
* 1개의 구독이 발생하는 시점에 Upstream 소스에 연결되도록 함
  *  Disposable disposable = publisher.subscribe(data -> log.info("# subscriber 1: {}", data));
* 첫번쨰 구독이 발생한 이후 2.1초에 구독을 해제
  * disposable.dispose()
* 이 시점에 모든 구독이 취소된 상태이기 때문에 연결이 해제됨
* 두번째 구독이 발생할 경우 Upstream 소스에 다시 연결됨
  * publisher.subscribe(data -> log.info("# subscriber 2: {}", data)); 

~~~java
public static void main(String[] args) throws InterruptedException {
    Flux<Long> publisher =
            Flux
                    .interval(Duration.ofMillis(500))

//                    .publish().autoConnect(1);
                    .publish().refCount(1);
    Disposable disposable = publisher.subscribe(data -> log.info("# subscriber 1: {}", data));

    Thread.sleep(2100L);
    disposable.dispose();

    publisher.subscribe(data -> log.info("# subscriber 2: {}", data));

    Thread.sleep(2500L);
}
~~~

* .publish().autoConnect(1)
~~~
11:32:08.776 [parallel-1] INFO com.example.test.Example - # subscriber 1: 0
11:32:09.275 [parallel-1] INFO com.example.test.Example - # subscriber 1: 1
11:32:09.780 [parallel-1] INFO com.example.test.Example - # subscriber 1: 2
11:32:10.280 [parallel-1] INFO com.example.test.Example - # subscriber 1: 3
11:32:10.778 [parallel-1] INFO com.example.test.Example - # subscriber 2: 4
11:32:11.280 [parallel-1] INFO com.example.test.Example - # subscriber 2: 5
11:32:11.776 [parallel-1] INFO com.example.test.Example - # subscriber 2: 6
11:32:12.276 [parallel-1] INFO com.example.test.Example - # subscriber 2: 7
11:32:12.778 [parallel-1] INFO com.example.test.Example - # subscriber 2: 8
~~~

* publish().refCount(1)
~~~
11:35:29.240 [parallel-1] INFO com.example.test.Example - # subscriber 1: 0
11:35:29.743 [parallel-1] INFO com.example.test.Example - # subscriber 1: 1
11:35:30.240 [parallel-1] INFO com.example.test.Example - # subscriber 1: 2
11:35:30.743 [parallel-1] INFO com.example.test.Example - # subscriber 1: 3
11:35:31.347 [parallel-2] INFO com.example.test.Example - # subscriber 2: 0
11:35:31.845 [parallel-2] INFO com.example.test.Example - # subscriber 2: 1
11:35:32.350 [parallel-2] INFO com.example.test.Example - # subscriber 2: 2
11:35:32.849 [parallel-2] INFO com.example.test.Example - # subscriber 2: 3
11:35:33.349 [parallel-2] INFO com.example.test.Example - # subscriber 2: 4
~~~

