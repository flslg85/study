# 14. Operators

## 14.2 Sequence 생성을 위한 Operator

### JustOrEmpty
* Just 는 emit 할 데이터가 null 일 경우, NullPointException 발생
* JustOrEmpty 는 emit 할 데이터가 null 일 경우, onCompleteSignal 을 전송
* `just(Optional.ofNullable(null))` -> onCompleteSignal
* `justOrEmpty(Optional.ofNullable(null))` -> onCompleteSignal

~~~Java
public static void main(String[] args) {
    Mono
            .justOrEmpty(null)
            .subscribe(data -> {},
                    error -> {},
                    () -> log.info("# onComplete"));
}
~~~

~~~
[main] INFO com.example.test.Example - # onComplete
~~~

### fromIterable
* Iterable 에 포함된 데이터를 emit 하는 Flux 생성

~~~Java
public static void main(String[] args) {
    Flux
            .fromIterable(SampleData.coins)
            .subscribe(coin ->
                    log.info("coin 명: {}, 현재가: {}", coin.getT1(), coin.getT2())
            );
}
~~~

~~~
08:18:32.636 [main] INFO com.example.test.Example - coin 명: BTC, 현재가: 52000000
08:18:32.640 [main] INFO com.example.test.Example - coin 명: ETH, 현재가: 1720000
08:18:32.640 [main] INFO com.example.test.Example - coin 명: XRP, 현재가: 533
08:18:32.641 [main] INFO com.example.test.Example - coin 명: ICX, 현재가: 2080
08:18:32.641 [main] INFO com.example.test.Example - coin 명: EOS, 현재가: 4020
08:18:32.641 [main] INFO com.example.test.Example - coin 명: BCH, 현재가: 558000
~~~

### fromStream
* stream 에 포함된 데이터를 emit 하는 Flux 를 생성
* stream 은 재사용할수 없으며, cancel, error, complete 시에 자동으로 닫힘

~~~Java
public static void main(String[] args) {
    Flux
        .fromStream(() -> SampleData.coinNames.stream())
        .filter(coin -> coin.equals("BTC") || coin.equals("ETH"))
        .subscribe(data -> log.info("{}", data));
}
~~~

~~~
08:20:03.850 [main] INFO com.example.test.Example - BTC
08:20:03.851 [main] INFO com.example.test.Example - ETH
~~~

### range
* n 부터 1씩 증가한 연속된 수를 emit 하는 Flux 를 생성

~~~Java
public static void main(String[] args) {
    Flux
        .range(5, 10)  // 5부터 시작해서 10개
        .subscribe(data -> log.info("{}", data));
}
~~~

~~~
08:21:55.673 [main] INFO com.example.test.Example - 5
08:21:55.674 [main] INFO com.example.test.Example - 6
08:21:55.674 [main] INFO com.example.test.Example - 7
08:21:55.674 [main] INFO com.example.test.Example - 8
08:21:55.674 [main] INFO com.example.test.Example - 9
08:21:55.674 [main] INFO com.example.test.Example - 10
08:21:55.674 [main] INFO com.example.test.Example - 11
08:21:55.674 [main] INFO com.example.test.Example - 12
08:21:55.674 [main] INFO com.example.test.Example - 13
08:21:55.674 [main] INFO com.example.test.Example - 14
~~~

### defer
* Operator 를 선언한 시점에 데이터를 emit 하지 않음
* 구독하는 시점에 데이터를 emit 하는 Flux, Mono 를 생성
* 데이터 emit 을 지연시키기 때문에 불필요한 프로세스를 줄일수 있음

~~~java
public static void main(String[] args) throws InterruptedException {
    log.info("# start: {}", LocalDateTime.now());
    Mono<LocalDateTime> justMono = Mono.just(LocalDateTime.now());
    Mono<LocalDateTime> deferMono = Mono.defer(() ->
                                                Mono.just(LocalDateTime.now()));

    Thread.sleep(2000);

    justMono.subscribe(data -> log.info("# onNext just1: {}", data));
    deferMono.subscribe(data -> log.info("# onNext defer1: {}", data));

    Thread.sleep(2000);

    justMono.subscribe(data -> log.info("# onNext just2: {}", data));
    deferMono.subscribe(data -> log.info("# onNext defer2: {}", data));
}
~~~

~~~
08:26:31.451 [main] INFO com.example.test.Example - # start: 2024-04-04T08:26:31.440
08:26:33.575 [main] INFO com.example.test.Example - # onNext just1: 2024-04-04T08:26:31.455
08:26:33.576 [main] INFO com.example.test.Example - # onNext defer1: 2024-04-04T08:26:33.576
08:26:35.583 [main] INFO com.example.test.Example - # onNext just2: 2024-04-04T08:26:31.455
08:26:35.583 [main] INFO com.example.test.Example - # onNext defer2: 2024-04-04T08:26:35.583
~~~

* deferMono 는 2초의 간격을 두고 emit 됨
  * `08:26:33.576` -> `08:26:35.583` 
* justMono 의 경우 지연 시간과 상관없이 동일한 시간을 출력함
  * `08:26:31.455`
* justMono 가 동일한 시간을 출력하는 이유?
  * Just 는 Hot Publisher 이기 때문에, Subscriber 의 구독 여부와 상관없이 데이터를 emit 함
  * 구독이 발생하면 emit 된 데이터를 replay 해서 Subscriber 에게 전달함
  * 따라서 justMono 의 경우 출력 결과가 같음


~~~java
public static void main(String[] args) throws InterruptedException {
    log.info("# start: {}", LocalDateTime.now());
    Mono
        .just("Hello")
        .delayElement(Duration.ofSeconds(3))
        .switchIfEmpty(sayDefault())
//      .switchIfEmpty(Mono.defer(() -> sayDefault()))
        .subscribe(data -> log.info("# onNext: {}", data));

    Thread.sleep(3500);
}

private static Mono<String> sayDefault() {
    log.info("# Say Hi");
    return Mono.just("Hi");
}
~~~

~~~
// `.switchIfEmpty(sayDefault())` -> sayDefault() 호출됨
08:35:22.647 [main] INFO com.example.test.Example - # start: 2024-04-04T08:35:22.635
08:35:22.736 [main] INFO com.example.test.Example - # Say Hi
08:35:25.762 [parallel-1] INFO com.example.test.Example - # onNext: Hello
~~~

~~~
// `.switchIfEmpty(Mono.defer(() -> sayDefault()))` -> sayDefault() 호출되지 않음
08:40:24.108 [main] INFO com.example.test.Example - # start: 2024-04-04T08:40:24.098
08:40:27.225 [parallel-1] INFO com.example.test.Example - # onNext: Hello
~~~

* `.switchIfEmpty(sayDefault())`
  * sayDefault 가 호출되지 않을것 처럼 보이지만 실제로 호출됨
* `.switchIfEmpty(Mono.defer(() -> sayDefault()))`
  * defer 를 사용하면 불필요한 호출을 막을수 있음


### using
* parameter 로 전달받은 resource 를 emit 하는 Flux 를 생성
* resourceSupplier
  * 읽어올 resource
* sourceSupplier
  * 읽어온 resource 를 emit 하는 Flux
* resourceCleanup
  * 종료 signal(onComplete 또는 onError)이 발생할 경우 resource 를 해제하는 등의 후처리를 할수 있게 함

~~~
public static <T, D> Flux<T> using(Callable<? extends D> resourceSupplier, 
                                   Function<? super D, ? extends Publisher<? extends T>> sourceSupplier, 
                                   Consumer<? super D> resourceCleanup) {
}
~~~

~~~java
public static void main(String[] args) throws IOException {
    Path path = new ClassPathResource("using_example.txt").getFile().toPath();

    Flux
            .using(() -> Files.lines(path), Flux::fromStream, Stream::close)
            .subscribe(log::info);
}
~~~

~~~
08:53:51.938 [main] INFO com.example.test.Example - test line1
08:53:51.938 [main] INFO com.example.test.Example - test line2
08:53:51.939 [main] INFO com.example.test.Example - test line3
~~~

### generate
* 프로그래밍 방식으로 Signal 이벤트를 발생시킴
* 동기적으로 데이터를 하나씩 순차적으로 emit 하고자 할때 사용
* SynchronousSink
  * 하나의 signal 만 동기적으로 발생시킬수 있으며, 최대 하나의 상태값만 emit 하는 인터페이스 

~~~java
public static <T, S> Flux<T> generate(Callable<S> stateSupplier, 
                                      BiFunction<S, SynchronousSink<T>, S> generator) {
}
~~~

~~~java
public static void main(String[] args) {
    Flux
            .generate(
                    () -> 0,  // 초깃값을 0으로 지정
                    (state, sink) -> {
                        sink.next(state);
                        if (state == 10)
                            sink.complete();  // onComplete signal 을 발생시켜 Sequence 가 종료되도록 함
                        return ++state;
                    })
            .subscribe(data -> log.info("# onNext: {}", data));
}
~~~

~~~
09:00:13.691 [main] INFO com.example.test.Example - # onNext: 0
09:00:13.692 [main] INFO com.example.test.Example - # onNext: 1
09:00:13.692 [main] INFO com.example.test.Example - # onNext: 2
09:00:13.692 [main] INFO com.example.test.Example - # onNext: 3
09:00:13.692 [main] INFO com.example.test.Example - # onNext: 4
09:00:13.692 [main] INFO com.example.test.Example - # onNext: 5
09:00:13.692 [main] INFO com.example.test.Example - # onNext: 6
09:00:13.692 [main] INFO com.example.test.Example - # onNext: 7
09:00:13.692 [main] INFO com.example.test.Example - # onNext: 8
09:00:13.692 [main] INFO com.example.test.Example - # onNext: 9
09:00:13.692 [main] INFO com.example.test.Example - # onNext: 10
~~~

* tuple 객체 사용하여 구구단 3단을 출력하는 예제

~~~java
public static void main(String[] args) {
    final int dan = 3;
    Flux
            .generate(
                    () -> Tuples.of(dan, 1),
                    (state, sink) -> {
                        sink.next(state.getT1() + " * " + state.getT2() + " = " + state.getT1() * state.getT2());
                        if (state.getT2() == 9) {
                            sink.complete();
                        }

                        return Tuples.of(state.getT1(), state.getT2() + 1);
                    }, 
                    state -> log.info("# 구구단 {}단 종료!", state.getT1()))
            .subscribe(data -> log.info("# onNext: {}", data));
}
~~~

~~~
09:07:46.571 [main] INFO com.example.test.Example - # onNext: 3 * 1 = 3
09:07:46.572 [main] INFO com.example.test.Example - # onNext: 3 * 2 = 6
09:07:46.572 [main] INFO com.example.test.Example - # onNext: 3 * 3 = 9
09:07:46.572 [main] INFO com.example.test.Example - # onNext: 3 * 4 = 12
09:07:46.572 [main] INFO com.example.test.Example - # onNext: 3 * 5 = 15
09:07:46.572 [main] INFO com.example.test.Example - # onNext: 3 * 6 = 18
09:07:46.572 [main] INFO com.example.test.Example - # onNext: 3 * 7 = 21
09:07:46.572 [main] INFO com.example.test.Example - # onNext: 3 * 8 = 24
09:07:46.572 [main] INFO com.example.test.Example - # onNext: 3 * 9 = 27
09:07:46.572 [main] INFO com.example.test.Example - # 구구단 3단 종료!
~~~

### create
* generate 처럼 프로그래밍 방식으로 Signal 이벤트를 발생시킴
* generate 와 차이점
  * generate 는 데이터를 동기적으로 한번에 한건씩 emit 함
  * create 는 데이터를 비동기적으로 한번에 여러건 emit 할수 있음

#### pull 방식으로 데이터 처리
~~~java
public class Example {
    static int SIZE = 0;
    static int COUNT = -1;
    final static List<Integer> DATA_SOURCE = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

    public static void main(String[] args) {
        log.info("# start");
        Flux.create((FluxSink<Integer> sink) -> {
            sink.onRequest(n -> {
                try {
                    Thread.sleep(1000L);
                    for (int i = 0; i < n; i++) {
                        if (COUNT >= 9) {
                            sink.complete();
                        } else {
                            COUNT++;
                            sink.next(DATA_SOURCE.get(COUNT));
                        }
                    }
                } catch (InterruptedException e) {}
            });

            sink.onDispose(() -> log.info("# clean up"));
        }).subscribe(new BaseSubscriber<Integer>() {
            @Override
            protected void hookOnSubscribe(Subscription subscription) {
                request(2);
            }

            @Override
            protected void hookOnNext(Integer value) {
                SIZE++;
                log.info("# onNext: {}", value);
                if (SIZE == 2) {
                    request(2);
                    SIZE = 0;
                }
            }

            @Override
            protected void hookOnComplete() {
                log.info("# onComplete");
            }
        });
    }
}
~~~

* 구독이 발생하면 hookOnSubscribe 에서 request(2) 를 호출하여 한번에 두개의 데이터를 요청
* sink.onRequest 메서드의 람다 표현식이 실행됨
* sink.next 로 지정한 개수 만큼 emit 함
* hookOnNext 에서 emit 된 데이터를 로그로 출력하고, request(2) 로 다시 2개의 데이터를 요청
* dataSource List 의 숫자를 모두 emit 하면 sink.complete 로 onComplete signal 을 발생 시킴
* hookOnComplete 에서 종료 로그를 출력
* sink.onDispose 에 람다 표현식이 실행되어 후처리 로그를 출력

~~~
09:12:53.811 [main] INFO com.example.test.Example - # start
09:12:55.037 [main] INFO com.example.test.Example - # onNext: 1
09:12:55.046 [main] INFO com.example.test.Example - # onNext: 2
09:12:56.049 [main] INFO com.example.test.Example - # onNext: 3
09:12:56.049 [main] INFO com.example.test.Example - # onNext: 4
09:12:57.054 [main] INFO com.example.test.Example - # onNext: 5
09:12:57.055 [main] INFO com.example.test.Example - # onNext: 6
09:12:58.057 [main] INFO com.example.test.Example - # onNext: 7
09:12:58.057 [main] INFO com.example.test.Example - # onNext: 8
09:12:59.064 [main] INFO com.example.test.Example - # onNext: 9
09:12:59.065 [main] INFO com.example.test.Example - # onNext: 10
09:13:00.072 [main] INFO com.example.test.Example - # onComplete
09:13:00.085 [main] INFO com.example.test.Example - # clean up
~~~

#### push 방식으로 데이터 처리
* 암호 화폐의 가격 변동이 있을때마다 변동되는 가격 데이터를 Subscriber 에게 비동기적으로 emit 하는 코드

~~~java
public class Example {
    public interface CryptoCurrencyPriceListener {
        void onPrice(List<Integer> priceList);
        void onComplete();
    }
    
    public static class CryptoCurrencyPriceEmitter {
        private CryptoCurrencyPriceListener listener;

        public void setListener(CryptoCurrencyPriceListener listener) {
            this.listener = listener;
        }

        public void flowInto() {
            listener.onPrice(Arrays.asList(50_000_000, 50_100_000, 50_700_000, 51_500_000, 52_000_000));
        }

        public void complete() {
            listener.onComplete();
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        CryptoCurrencyPriceEmitter priceEmitter = new CryptoCurrencyPriceEmitter();

        Flux.create((FluxSink<Integer> sink) ->
                        priceEmitter.setListener(new CryptoCurrencyPriceListener() {
                            @Override
                            public void onPrice(List<Integer> priceList) {
                                priceList.forEach(sink::next);
                            }

                            @Override
                            public void onComplete() {
                                sink.complete();
                            }
                        }))
                .publishOn(Schedulers.parallel())
                .subscribe(
                        data -> log.info("# onNext: {}", data),
                        error -> {},
                        () -> log.info("# onComplete"));

        Thread.sleep(3000L);
        log.info("# priceEmitter.flowInto");
        priceEmitter.flowInto();

        Thread.sleep(2000L);
        log.info("# priceEmitter.complete");
        priceEmitter.complete();
        Thread.sleep(2000L);
    }
}
~~~

* 가격 변동이 있을때마다 onPrice() 메서드가 호출됨
* 가격 변동을 발생시키기 위해 flowInto() 메서드를 호출

~~~
09:34:08.840 [main] INFO com.example.test.Example - # priceEmitter.flowInto
09:34:08.850 [parallel-1] INFO com.example.test.Example - # onNext: 50000000
09:34:08.855 [parallel-1] INFO com.example.test.Example - # onNext: 50100000
09:34:08.855 [parallel-1] INFO com.example.test.Example - # onNext: 50700000
09:34:08.855 [parallel-1] INFO com.example.test.Example - # onNext: 51500000
09:34:08.855 [parallel-1] INFO com.example.test.Example - # onNext: 52000000
09:34:10.855 [main] INFO com.example.test.Example - # priceEmitter.complete
09:34:10.859 [parallel-1] INFO com.example.test.Example - # onComplete
~~~

#### backpressure 방식으로 데이터 처리
* 한번에 여러건의 데이터를 비동기적으로 emit 할수 있기 때문에 Backpressure 전략이 필요

~~~java
public class Example {
    static int start = 1;
    static int end = 4;

    public static void main(String[] args) throws InterruptedException {
        Flux.create((FluxSink<Integer> emitter) -> {
                            emitter.onRequest(n -> {
                                log.info("# requested: " + n);
                                try {
                                    Thread.sleep(500L);
                                    for (int i = start; i <= end; i++) {
                                        emitter.next(i);
                                    }
                                    start += 4;
                                    end += 4;
                                } catch (InterruptedException e) {
                                }
                            });

                            emitter.onDispose(() -> {
                                log.info("# clean up");
                            });
                        },
                        FluxSink.OverflowStrategy.DROP)
                .subscribeOn(Schedulers.boundedElastic())
                .publishOn(Schedulers.parallel(), 2)
                .subscribe(data -> log.info("# onNext: {}", data));

        Thread.sleep(3000L);
    }

}
~~~

~~~
09:37:00.411 [boundedElastic-1] INFO com.example.test.Example - # requested: 2
09:37:00.915 [parallel-1] INFO com.example.test.Example - # onNext: 1
09:37:00.923 [parallel-1] INFO com.example.test.Example - # onNext: 2
09:37:00.932 [boundedElastic-1] INFO com.example.test.Example - # requested: 2
09:37:01.439 [parallel-1] INFO com.example.test.Example - # onNext: 5
09:37:01.439 [parallel-1] INFO com.example.test.Example - # onNext: 6
09:37:01.440 [boundedElastic-1] INFO com.example.test.Example - # requested: 2
09:37:01.945 [parallel-1] INFO com.example.test.Example - # onNext: 9
09:37:01.945 [parallel-1] INFO com.example.test.Example - # onNext: 10
09:37:01.946 [boundedElastic-1] INFO com.example.test.Example - # requested: 2
09:37:02.450 [parallel-1] INFO com.example.test.Example - # onNext: 13
09:37:02.451 [parallel-1] INFO com.example.test.Example - # onNext: 14
09:37:02.452 [boundedElastic-1] INFO com.example.test.Example - # requested: 2
09:37:02.957 [parallel-1] INFO com.example.test.Example - # onNext: 17
09:37:02.958 [parallel-1] INFO com.example.test.Example - # onNext: 18
09:37:02.959 [boundedElastic-1] INFO com.example.test.Example - # requested: 2
~~~

## 14.3 Sequence 필터링

### filter
* emit 된 데이터 중에서 조건에 일치하는 데이터만 Downstream 으로 emit

~~~java
public static void main(String[] args) {
    Flux
        .range(1, 20)
        .filter(num -> num % 2 != 0)
        .subscribe(data -> log.info("# onNext: {}", data));
}
~~~

~~~
09:39:51.035 [main] INFO com.example.test.Example - # onNext: 1
09:39:51.036 [main] INFO com.example.test.Example - # onNext: 3
09:39:51.036 [main] INFO com.example.test.Example - # onNext: 5
09:39:51.036 [main] INFO com.example.test.Example - # onNext: 7
09:39:51.036 [main] INFO com.example.test.Example - # onNext: 9
09:39:51.036 [main] INFO com.example.test.Example - # onNext: 11
09:39:51.036 [main] INFO com.example.test.Example - # onNext: 13
09:39:51.036 [main] INFO com.example.test.Example - # onNext: 15
09:39:51.036 [main] INFO com.example.test.Example - # onNext: 17
09:39:51.036 [main] INFO com.example.test.Example - # onNext: 19
~~~

### filterWhen
* Inner Sequence 를 통해 조건에 맞는 데이터인지를 비동기적으로 필터링을 수행
* 테스트 결과가 true 라면 Downstream 으로 emit 함 

~~~java
public static void main(String[] args) throws InterruptedException {
    Map<CovidVaccine, Tuple2<CovidVaccine, Integer>> vaccineMap = getCovidVaccines();
    Flux
            .fromIterable(SampleData.coronaVaccineNames)
            .filterWhen(vaccine -> Mono
                    .just(vaccineMap.get(vaccine).getT2() >= 3_000_000)
                    .publishOn(Schedulers.parallel()))
            .subscribe(data -> log.info("# onNext: {}", data));

    Thread.sleep(1000);
}
~~~


### skip
* 파라미터로 입력 받은 숫자만큼 건너뛴 후, Downstream 으로 emit
* 시간 단위로 건너뛰기도 가능

~~~java
public final Flux<T> skip(long skipped)
public final Flux<T> skip(Duration timespan)
~~~

* 숫자로 skip

~~~java
public static void main(String[] args) throws InterruptedException {
    Flux
            .interval(Duration.ofSeconds(1))
            .skip(2)
            .subscribe(data -> log.info("# onNext: {}", data));

    Thread.sleep(5500L);
}
~~~

* interval 로 1초에 한번씩 데이터를 emit 함
* `Thread.sleep(5500L)` main thread 가 5.5 초까지 실행되므로 0-4 까지 5개가 subscriber 로 전달됨  
* 0부터 증가하기 때문에 skip 으로 0,1 출력되지 않음

~~~
09:45:45.687 [parallel-1] INFO com.example.test.Example - # onNext: 2
09:45:46.691 [parallel-1] INFO com.example.test.Example - # onNext: 3
09:45:47.688 [parallel-1] INFO com.example.test.Example - # onNext: 4
~~~

* 시간단위로 skip

~~~java
public static void main(String[] args) throws InterruptedException {
    Flux
        .interval(Duration.ofMillis(300))
        .skip(Duration.ofSeconds(1))
        .subscribe(data -> log.info("# onNext: {}", data));

    Thread.sleep(2000L);
}
~~~

* interval 0.3 초씩 데이터를 emit 함
* 1초 skip 하여 0.9초까지 만들어진 0,1,2 가 skip 됨

~~~
09:51:17.108 [parallel-2] INFO com.example.test.Example - # onNext: 3
09:51:17.407 [parallel-2] INFO com.example.test.Example - # onNext: 4
09:51:17.706 [parallel-2] INFO com.example.test.Example - # onNext: 5
~~~


### take
* 파라미터로 입력 받는 숫자만큼 emit
  * skip 은 파라미터로 입력 받는 숫자만큼 건너뛰고 emit
* 시간 단위로 emit 도 가능

~~~java
public final Flux<T> take(long n)
public final Flux<T> take(Duration timespan)
~~~

~~~java
public static void main(String[] args) throws InterruptedException {
    Flux
        .interval(Duration.ofSeconds(1))
        .take(3)
        .subscribe(data -> log.info("# onNext: {}", data));

    Thread.sleep(4000L);
}
~~~

~~~
10:03:37.370 [parallel-1] INFO com.example.test.Example - # onNext: 0
10:03:38.367 [parallel-1] INFO com.example.test.Example - # onNext: 1
10:03:39.363 [parallel-1] INFO com.example.test.Example - # onNext: 2
~~~

### takeLast
* 파라미터로 입력 받은 개수만큼 가장 마지막에 emit 된 데이터를 Downstream 으로 emit

~~~java
public static void main(String[] args) {
    Flux
            .fromIterable(Arrays.asList(
                    Tuples.of(2010, 565L),
                    Tuples.of(2011, 36_094L),
                    Tuples.of(2012, 17_425L),
                    Tuples.of(2013, 1_405_209L),
                    Tuples.of(2014, 1_237_182L),
                    Tuples.of(2015, 557_603L),
                    Tuples.of(2016, 1_111_811L),
                    Tuples.of(2017, 22_483_583L),
                    Tuples.of(2018, 19_521_543L),
                    Tuples.of(2019, 15_761_568L),
                    Tuples.of(2020, 22_439_002L),
                    Tuples.of(2021, 63_364_000L)
            ))
            .takeLast(2)
            .subscribe(tuple -> log.info("# onNext: {}, {}", tuple.getT1(), tuple.getT2()));
}
~~~

* 가장 마지막 2 개인 2020, 2021 출력됨

~~~
10:06:24.447 [main] INFO com.example.test.Example - # onNext: 2020, 22439002
10:06:24.449 [main] INFO com.example.test.Example - # onNext: 2021, 63364000
~~~

### takeUntil
* 파라미터로 입력한 람다 표현식(Predicate)이 true 가 될때까지 Downstream 으로 emit
* Predicate 를 평가할때 사용한 데이터가 포함

~~~java
public static void main(String[] args) {
    Flux
            .fromIterable(Arrays.asList(
                    Tuples.of(2010, 565L),
                    Tuples.of(2011, 36_094L),
                    Tuples.of(2012, 17_425L),
                    Tuples.of(2013, 1_405_209L),
                    Tuples.of(2014, 1_237_182L),
                    Tuples.of(2015, 557_603L),
                    Tuples.of(2016, 1_111_811L),
                    Tuples.of(2017, 22_483_583L),
                    Tuples.of(2018, 19_521_543L),
                    Tuples.of(2019, 15_761_568L),
                    Tuples.of(2020, 22_439_002L),
                    Tuples.of(2021, 63_364_000L)
            ))
            .takeUntil(tuple -> tuple.getT2() > 20_000_000)
            .subscribe(tuple -> log.info("# onNext: {}, {}", tuple.getT1(), tuple.getT2()));
}
~~~

* 20_000_000 이상인 데이터가 처음 나오는 시점은 2017 
* Predicate 를 평가할때 사용한 데이터가 포함되기 때문에 2017 까지 출력됨

~~~
10:09:19.856 [main] INFO com.example.test.Example - # onNext: 2010, 565
10:09:19.858 [main] INFO com.example.test.Example - # onNext: 2011, 36094
10:09:19.858 [main] INFO com.example.test.Example - # onNext: 2012, 17425
10:09:19.858 [main] INFO com.example.test.Example - # onNext: 2013, 1405209
10:09:19.858 [main] INFO com.example.test.Example - # onNext: 2014, 1237182
10:09:19.858 [main] INFO com.example.test.Example - # onNext: 2015, 557603
10:09:19.858 [main] INFO com.example.test.Example - # onNext: 2016, 1111811
10:09:19.858 [main] INFO com.example.test.Example - # onNext: 2017, 22483583
~~~


### takeWhile
* 파라미터로 입력한 람다 표현식(Predicate)이 true 가 될때까지 Downstream 으로 emit
* Predicate 를 평가할때 사용한 데이터가 Downstream 으로 emit 되지 않음

~~~java
public static void main(String[] args) {
    Flux
            .fromIterable(Arrays.asList(
                    Tuples.of(2010, 565L),
                    Tuples.of(2011, 36_094L),
                    Tuples.of(2012, 17_425L),
                    Tuples.of(2013, 1_405_209L),
                    Tuples.of(2014, 1_237_182L),
                    Tuples.of(2015, 557_603L),
                    Tuples.of(2016, 1_111_811L),
                    Tuples.of(2017, 22_483_583L),
                    Tuples.of(2018, 19_521_543L),
                    Tuples.of(2019, 15_761_568L),
                    Tuples.of(2020, 22_439_002L),
                    Tuples.of(2021, 63_364_000L)
            ))
            .takeWhile(tuple -> tuple.getT2() < 20_000_000)
            .subscribe(tuple -> log.info("# onNext: {}, {}", tuple.getT1(), tuple.getT2()));
}
~~~

* 20_000_000 보다 큰 값이 나오는 처음이 2017
* 2016 이전까지는 데이터가 출력되고, Predicate 를 평가할때 사용한 데이터 2017 은 출력되지 않음

~~~
10:12:21.589 [main] INFO com.example.test.Example - # onNext: 2010, 565
10:12:21.590 [main] INFO com.example.test.Example - # onNext: 2011, 36094
10:12:21.591 [main] INFO com.example.test.Example - # onNext: 2012, 17425
10:12:21.591 [main] INFO com.example.test.Example - # onNext: 2013, 1405209
10:12:21.591 [main] INFO com.example.test.Example - # onNext: 2014, 1237182
10:12:21.591 [main] INFO com.example.test.Example - # onNext: 2015, 557603
10:12:21.591 [main] INFO com.example.test.Example - # onNext: 2016, 1111811
~~~


### next
* Upstream 에서 emit 되는 데이터중 첫번째 데이터만 Downstream 으로 emit 함
* 만약 Upstream 에서 emit 되는 데이터가 empty 라면 Downstream 으로 empty Mono 를 emit 함

~~~java
public static void main(String[] args) {
    Flux
            .fromIterable(Arrays.asList(
                    Tuples.of(2010, 565L),
                    Tuples.of(2011, 36_094L),
                    Tuples.of(2012, 17_425L),
                    Tuples.of(2013, 1_405_209L),
                    Tuples.of(2014, 1_237_182L),
                    Tuples.of(2015, 557_603L),
                    Tuples.of(2016, 1_111_811L),
                    Tuples.of(2017, 22_483_583L),
                    Tuples.of(2018, 19_521_543L),
                    Tuples.of(2019, 15_761_568L),
                    Tuples.of(2020, 22_439_002L),
                    Tuples.of(2021, 63_364_000L)
            ))
            .next()
            .subscribe(tuple -> log.info("# onNext: {}, {}",  tuple.getT1(), tuple.getT2()));
}
~~~

~~~
10:17:23.658 [main] INFO com.example.test.Example - # onNext: 2010, 565
~~~

## 14.4 Sequence 변환

### map
* Upstream 에서 emit 된 데이터를 mapper Function 을 사용하여 변환한 후, Downstream 으로 emit

#### map sample 1
~~~java
public static void main(String[] args) {
    Flux
        .just("1-Circle", "3-Circle", "5-Circle")
        .map(circle -> circle.replace("Circle", "Rectangle"))
        .subscribe(data -> log.info("# onNext: {}", data));
}
~~~

~~~
10:19:10.818 [main] INFO com.example.test.Example - # onNext: 1-Rectangle
10:19:10.819 [main] INFO com.example.test.Example - # onNext: 3-Rectangle
10:19:10.819 [main] INFO com.example.test.Example - # onNext: 5-Rectangle
~~~

#### map sample 2

~~~java
public class Example {
    public static void main(String[] args) {
        final double buyPrice = 50_000_000;
        Flux
                .fromIterable(SampleData.btcTopPricesPerYear)
                .filter(tuple -> tuple.getT1() == 2021)
                .doOnNext(data -> log.info("# doOnNext: {}", data))
                .map(tuple -> calculateProfitRate(buyPrice, tuple.getT2()))
                .subscribe(data -> log.info("# onNext: {}%", data));
    }

    private static double calculateProfitRate(final double buyPrice, Long topPrice) {
        return (topPrice - buyPrice) / buyPrice * 100;
    }
}
~~~

~~~
10:20:39.693 [main] INFO com.example.test.Example - # doOnNext: [2021,63364000]
10:20:39.695 [main] INFO com.example.test.Example - # onNext: 26.728%
~~~

### flatMap
* Upstream 에서 emit 된 한건의 데이터가 Inner Sequence 에서 여러건의 데이터로 변환됨
* 여러건의 데이터가 flatten 작업과 merge 작업을 거쳐 Downstream 으로 emit

#### flatMap sample 1
~~~java
public static void main(String[] args) {
    Flux
        .just("Good", "Bad")
        .flatMap(feeling -> Flux
                                .just("Morning", "Afternoon", "Evening")
                                .map(time -> feeling + " " + time))
        .subscribe(log::info);
}
~~~

~~~
10:23:35.456 [main] INFO com.example.test.Example - Good Morning
10:23:35.456 [main] INFO com.example.test.Example - Good Afternoon
10:23:35.456 [main] INFO com.example.test.Example - Good Evening
10:23:35.456 [main] INFO com.example.test.Example - Bad Morning
10:23:35.456 [main] INFO com.example.test.Example - Bad Afternoon
10:23:35.456 [main] INFO com.example.test.Example - Bad Evening
~~~

#### flatMap sample 2
* 비동기적으로 데이터를 emit

~~~java
public static void main(String[] args) throws InterruptedException {
    Flux
            .range(2, 8)
            .flatMap(dan -> Flux
                    .range(1, 9)
                    .publishOn(Schedulers.parallel())
                    .map(n -> dan + " * " + n + " = " + dan * n))
            .subscribe(log::info);

    Thread.sleep(100L);
}
~~~

* 3 단 로그를 보면 순서 보장이 되지 않음
~~~
10:26:47.951 [parallel-1] INFO com.example.test.Example - 2 * 1 = 2
...
10:26:47.953 [parallel-1] INFO com.example.test.Example - 2 * 8 = 16
10:26:47.953 [parallel-1] INFO com.example.test.Example - 2 * 9 = 18
10:26:47.956 [parallel-2] INFO com.example.test.Example - 3 * 1 = 3
10:26:47.956 [parallel-2] INFO com.example.test.Example - 4 * 1 = 4
...
10:26:47.956 [parallel-2] INFO com.example.test.Example - 4 * 9 = 36
10:26:47.956 [parallel-2] INFO com.example.test.Example - 5 * 1 = 5
...
10:26:47.956 [parallel-2] INFO com.example.test.Example - 5 * 9 = 45
10:26:47.956 [parallel-2] INFO com.example.test.Example - 6 * 1 = 6
...
10:26:47.956 [parallel-2] INFO com.example.test.Example - 6 * 9 = 54
10:26:47.956 [parallel-2] INFO com.example.test.Example - 7 * 1 = 7
...
10:26:47.956 [parallel-2] INFO com.example.test.Example - 7 * 9 = 63
10:26:47.956 [parallel-2] INFO com.example.test.Example - 8 * 1 = 8
...
10:26:47.957 [parallel-2] INFO com.example.test.Example - 8 * 9 = 72
10:26:47.957 [parallel-2] INFO com.example.test.Example - 9 * 1 = 9
...
10:26:47.957 [parallel-2] INFO com.example.test.Example - 9 * 9 = 81
10:26:47.957 [parallel-2] INFO com.example.test.Example - 3 * 2 = 6
10:26:47.957 [parallel-2] INFO com.example.test.Example - 3 * 3 = 9
10:26:47.957 [parallel-2] INFO com.example.test.Example - 3 * 4 = 12
10:26:47.957 [parallel-2] INFO com.example.test.Example - 3 * 5 = 15
10:26:47.957 [parallel-2] INFO com.example.test.Example - 3 * 6 = 18
10:26:47.957 [parallel-2] INFO com.example.test.Example - 3 * 7 = 21
10:26:47.957 [parallel-2] INFO com.example.test.Example - 3 * 8 = 24
10:26:47.957 [parallel-2] INFO com.example.test.Example - 3 * 9 = 27
~~~

### concat
* 파라미터로 입력되는 Publisher 의 Sequence 를 연결해서 데이터를 순차적으로 emit

#### concat sample 1 

~~~java
public static void main(String[] args) {
    Flux
            .concat(Flux.just(1, 2, 3), Flux.just(4, 5))
            .subscribe(data -> log.info("# onNext: {}", data));
}
~~~

~~~
10:29:23.290 [main] INFO com.example.test.Example - # onNext: 1
10:29:23.292 [main] INFO com.example.test.Example - # onNext: 2
10:29:23.292 [main] INFO com.example.test.Example - # onNext: 3
10:29:23.292 [main] INFO com.example.test.Example - # onNext: 4
10:29:23.292 [main] INFO com.example.test.Example - # onNext: 5
~~~

#### concat sample 2

~~~java
public static void main(String[] args) {
    Flux
            .concat(
                    Flux.fromIterable(Arrays.asList(
                            Tuples.of(CovidVaccine.AstraZeneca, 3_000_000),
                            Tuples.of(CovidVaccine.Janssen, 2_000_000)
                    )),
                    Flux.fromIterable(Arrays.asList(
                            Tuples.of(CovidVaccine.Pfizer, 1_000_000),
                            Tuples.of(CovidVaccine.Moderna, 4_000_000)
                    )),
                    Flux.fromIterable(Arrays.asList(
                            Tuples.of(CovidVaccine.Novavax, 2_500_000)
                    )))
            .subscribe(data -> log.info("# onNext: {}", data));
}
~~~

~~~
10:32:33.404 [main] INFO com.example.test.Example - # onNext: [AstraZeneca,3000000]
10:32:33.406 [main] INFO com.example.test.Example - # onNext: [Janssen,2000000]
10:32:33.406 [main] INFO com.example.test.Example - # onNext: [Pfizer,1000000]
10:32:33.406 [main] INFO com.example.test.Example - # onNext: [Moderna,4000000]
10:32:33.406 [main] INFO com.example.test.Example - # onNext: [Novavax,2500000]
~~~

### merge
* 파라미터로 입력되는 Publisher 의 Sequence 에서 emit 된 데이터를 interleave 방식으로 병합
  * interleave 는 emit 된 시간 순서대로 처리하는 방식
* concat 처럼 하나의 Publisher 의 Sequence 가 종료될때까지 나머지 Publisher 의 Sequence 가 대기하는 것이 아니라, 모든 Publisher 의 Sequence 가 즉시 subscribe 됨

#### merge sample 1

~~~java
public static void main(String[] args) throws InterruptedException {
    Flux
            .merge(
                    Flux.just(1, 2, 3, 4).delayElements(Duration.ofMillis(300L)),
                    Flux.just(5, 6, 7).delayElements(Duration.ofMillis(500L))
            )
            .subscribe(data -> log.info("# onNext: {}", data));

    Thread.sleep(2000L);
}
~~~

* parallel 6개로 실행되었고, onNext 를 보면 순서가 보장되지 않음을 알수 있음

~~~
10:38:06.134 [parallel-1] INFO com.example.test.Example - # onNext: 1
10:38:06.338 [parallel-2] INFO com.example.test.Example - # onNext: 5
10:38:06.443 [parallel-3] INFO com.example.test.Example - # onNext: 2
10:38:06.745 [parallel-5] INFO com.example.test.Example - # onNext: 3
10:38:06.844 [parallel-4] INFO com.example.test.Example - # onNext: 6
10:38:07.051 [parallel-6] INFO com.example.test.Example - # onNext: 4
10:38:07.349 [parallel-7] INFO com.example.test.Example - # onNext: 7
~~~

#### merge sample 2

~~~java
public class Example {
    public static void main(String[] args) throws InterruptedException {
        String[] usaStates = {
                "Ohio", "Michigan", "New Jersey", "Illinois", "New Hampshire",
                "Virginia", "Vermont", "North Carolina", "Ontario", "Georgia"
        };

        Flux
                .merge(getMeltDownRecoveryMessage(usaStates))
                .subscribe(log::info);

        Thread.sleep(2000L);
    }

    public static Map<String, Mono<String>> nppMap = Map.of(
            "Ontario", Mono.just("Ontario Done").delayElement(Duration.ofMillis(1500L)),
            "Vermont", Mono.just("Vermont Done").delayElement(Duration.ofMillis(400L)),
            "New Hampshire", Mono.just("New Hampshire Done").delayElement(Duration.ofMillis(700L)),
            "New Jersey", Mono.just("New Jersey Done").delayElement(Duration.ofMillis(500L)),
            "Ohio", Mono.just("Ohio Done").delayElement(Duration.ofMillis(1000L)),
            "Michigan", Mono.just("Michigan Done").delayElement(Duration.ofMillis(200L)),
            "Illinois", Mono.just("Illinois Done").delayElement(Duration.ofMillis(300L)),
            "Virginia", Mono.just("Virginia Done").delayElement(Duration.ofMillis(600L)),
            "North Carolina", Mono.just("North Carolina Done").delayElement(Duration.ofMillis(800L)),
            "Georgia", Mono.just("Georgia Done").delayElement(Duration.ofMillis(900L))
    );

    private static List<Mono<String>> getMeltDownRecoveryMessage(String[] usaStates) {
        List<Mono<String>> messages = new ArrayList<>();
        for (String state : usaStates) {
            messages.add(SampleData.nppMap.get(state));
        }

        return messages;
    }
}
~~~

~~~
10:44:50.997 [parallel-2] INFO com.example.test.Example - Michigan Done
10:44:51.100 [parallel-4] INFO com.example.test.Example - Illinois Done
10:44:51.200 [parallel-7] INFO com.example.test.Example - Vermont Done
10:44:51.300 [parallel-3] INFO com.example.test.Example - New Jersey Done
10:44:51.400 [parallel-6] INFO com.example.test.Example - Virginia Done
10:44:51.500 [parallel-5] INFO com.example.test.Example - New Hampshire Done
10:44:51.600 [parallel-8] INFO com.example.test.Example - North Carolina Done
10:44:51.698 [parallel-10] INFO com.example.test.Example - Georgia Done
10:44:51.800 [parallel-1] INFO com.example.test.Example - Ohio Done
10:44:52.300 [parallel-9] INFO com.example.test.Example - Ontario Done
~~~
