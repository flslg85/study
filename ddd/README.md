# 도메인 모델
- 기술로 부터 자유로운 도메인 모델을 이야기 함
  - 기술은 아키텍처 전반에 걸쳐 산재해 있지만, 도메인 모델은 기술로부터 최대한 자유로워야 한다.
  - 예를 들면. 트랜잭션은 애플리케이션 서비스에 의해 관리되는 것이지, 도메인 모델에 의해 관리되는 것이 아니다.


# 전략적 설계

## Bounded Context(바운디드 컨텍스트)
- 도메인 모델을 분리하는 전략적 설계 패턴
- 동일한 context 의 범위를 표현(도메인 범위라고 생각함, MSA 에 마이크로 서비스 또는 도메인 서비스를 이야기 함)
- 모델이 구현되는 곳이고 bounded context 마다 각각 분리된 소프트웨어 산출물이 나옴
- 단일 팀에만 할당돼야하고 독립적인 소스 코드 리파지토리가 있어야함
- bounded context 마다 소스 코드와 데이터베이스 스키마도 명확히 분리 해야함
- 핵심이 되는 개념들은 포용하고 나머지는 모두 제외시켜야 함

### Problem Space(문제 영역), Solution Space(해결 영역)
- 문제 영역
  - 목표에 대해 이야기 하는 영역으로 간단한 다이어그램을 사용할 수도 있음
- 해결 영역
  - 문제 영역에서 논의된 것을 핵심 도메인으로 해결 방안을 구현하는 영역

### 핵심 도메인
- bounded context 가 조직의 핵심 계획으로 개발되고 있을때 이를 핵심 도메인이라고 함


## Ubiquitous Language(보편언어)
- bounded context 안에서 일하는 모든 팀 구성원이 사용하는 언어를 이야기함
- 팀 모두가 언어가 가진 제약 사항과 정확한 의미를 이해하고 있어야함.
- 소프트웨어 모델 안에 구현되기 때문에 엄격, 정확, 엄중, 단호 해야함
- 시나리오를 작성함으로써 보편언어 개발을 시작할 수 있음

### 시나리오
- 소프트웨어 프로젝트에서 흔히 말하는 유스케이스나 사용자 스토리 같은 것을 의미하지 않음
- 도메인 모델이 어떻게 동작할 것인지를 나타내는 세부사항을 시나리오로 만들어야 함

### 행위 주도 개발 - BDD(Behavior Driven Development) 
- 목적은 보편언어와 모델이 시나리오를 준수하고 있는지 확인하기 위함
- given / when / then 을 사용해 작성한 시나리오를 검증
- 장점은 신속하게 시나리오를 검증할 수 있음



## SubDomains(서브도메인)
- 서브 도메인 개념은 그냥 일반적인 마이크로 서비스에 포함된 여러 도메인을 의미하는 것이라고 생각됨
- 서브 도메인 유형
  - 핵심 도메인: 보편언어
  - 지원 서브 도메인
  - 일반 서브 도메인
- 레거시 시스템을 논리적 도메인 모델로 쪼개서 각각의 모델 할당을 서브도메인으로 사용할 수 있음
- bounded context 와 subdomains 는 1:1 관계가 되도록 함
  - subdomains 이 2개 일때 2개의 bounded context 로 분리하는 것이 좋지만, 현실적으로 어렵다면 모듈로 분리


## Context Mapping(컨텍스트 매핑)
- 핵심 도메인을 다른 bounded context 와 통합하는 방법
  - 다른 마이크로 서비스와 어떻게 연결시킬거냐에 대한 내용

### 컨텍스트 매핑의 종류
- 파트너십
  - 두 팀이 매우 밀접한 관련이 있기 때문에 상호간 의존적인 작업이나 여러 일정들을 조율하고 지속적으로 통합하는 노력이 필요함
- Shared Kernel(공유 커널)
  - 팀 사이에 공통인 모델을 공유하는 관계
- Downstream(고객) - Upstream(공급자)
  - 고객이 원하는 것을 제공해야 하기 때문에 공급자가 관계를 주도함
  - 고객이 언제 무엇을 받게 될지는 공급자가 결정
- Conformist(준수자)
  - 고객이 공급자의 보편언어를 계속 변환하는 것이 어렵기 때문에, 공급자의 모델을 그대로 따르는 것을 이야기 함
  - ex> 판매자가 아마존 시스템과 통합하려고 할때 판매자는 아마존 모델을 사용하게 됨
- Anticorruption Layer(반부패 계층)
  - 가장 방어적인 컨텍스트 매핑 관계
  - 공급자의 모델을 고객의 모델로 번역하는 계층을 만드는것
  - 통합에 용이, 외부의 이질적인 개념으로 부터 독립성을 유지
  - 모델 변경 작업의 비용이 높아질 수 있음
- Open Host Service(공개 호스트 서비스)
  - bounded context 에 대한 접근을 제공하는 프로토콜이나 인터페이스를 정의
  - 프로토콜: 모두가 용이하게 사용할 수 있도록 공개되어 있음
  - 인터페이스: API(application programming interface)로 제공하는 서비스
  - 수많은 레거시 시스템을 맞닥뜨리는 것보다 API 로 접근하는 것이 괜찮은 선택일 수 있음
- 공표된 언어
  - XML 스키마, JSON 스키마, Protobuf, Avro 로 정의할 수 있음  
- Separate Ways(각자의 길)
  - 외부 연동하지 않고 bounded context 에 내부적으로 구현하는 것을 이야기 함


### 컨텍스트 매핑 인터페이스
- SOAP(Simple Object Access Protocol) 를 이용한 RPC(Remote Procedure Calls)
  - 다른 시스템이 서비스를 사용할 때 로컬 프로시저나 메서드를 호출하는 것처럼 사용한다는 개념
  - 이 방식은 견고함이 떨어질 수 있다는 문제점이 있음 
    - 네트워크 장애나 지연이 생길수 있음
    - 네트워크에 문제가 생기면 호출은 에러 결과만 받은 채 실패하게 됨
  - 사용하기 쉬워 보인다고 해서 속으면 안됨
- RESTful HTTP
  - 공개 호스트 서비스와 공표된 언어를 제공해야 함
  - 도메인 모델 안에 직접적으로 애그리게잇을 반영하는 REST 리소스를 설계하는 실수를 많이 함
    - 도메인 모델이랑 REST 리소스 모델이랑 분리해서 쓰라는 이야기(Domain -> DTO 로 변환)
- 메시징(Publish - Subscribe)
  - 가장 견고한 형태의 통합
  - 즉각적인 결과가 필수적이지 않을때 메시징을 이용해 견고한 시스템을 구축하는 것이 좋은 선택임
  - 매시징 매커니즘
    - At-least-once delivery(적어도 한번의 전달)을 통해 모든 메시지의 수신을 보장
      - 메시지가 여러번 전달될 수 있음
    - 구독 bounded context 는 Idempotent Receiver(멱등 수신자)로 구현돼야 함
      - 여러번 수행되더라도 동일한 결과가 되도록 만드는 방식

### 컨텍스트 매핑 사례
- 모두 담는 것 vs 다시 쿼리하는 것 사이의 장단점




## Context Map
- 2개의 Bounded Context 를 통합하면서 그 사이에 존재하는 팀의 관계, 기술적 매커니즘을 정의




# 전술적 설계

## Value Object(객체)
- 고유한 식별성이 없음
- 값 형태 속성을 비교함으로써 동일성이 결정됨

## Entity
- 고유한 식별성을 갖음
  - 다른 모델링 수단들과 엔티티의 구분은 유일성, 즉 독립성에 있음
- 상태는 계속 변할수 있음

## Aggregate(애그리게잇)
- 1 개 이상의 엔티티로 구성되고 그중에 하나의 엔티티를 애그리게잇 루트라고 부름
  - 애그리게잇 루트는 애그리게잇 안의 다른 모든 요소를 소유함
- 애그리게잇은 값 객체를 포함할 수 있음
- 애그리게잇은 일관성 있는 트랜잭션 경계를 형성함
  - 여기서 트랜잭션은 디비의 트랜잭션이 아니라 비지니스 로직의 처리 단위라고 봐야함

### 애그리게잇 경험 법칙
- 애그리게잇 경계 내에서 비지니스 불변사항들을 보호
- 작은 애그리게잇으로 설계
  - 로직이 복잡하지 않으므로 이해하기 쉽고 테스트 코드 만들기도 좋음
  - 단일 책임 원칙 - SRP(Single Responsibility Principle)
    - 애그리게잇이 너무 많은 일을 하면 SRP 를 따르지 않는 것이고, 이후 애그리게잇 크기에 대해 재논의할 가능성이 큼
- 오직 ID 를 통해 다른 애그리게잇을 참고
  - 애그리게잇을 작게 유지하고, 동일한 트랜잭션 내에 여러 애그리게잇을 수정하려는 접근을 방지해 줌
  - ID 외에 다른 애그리게잇 내의 객체 레퍼런스를 얻어낼 수 있는 방법이 없음
  - 식별자만을 통해 레퍼런스를 얻는 규칙의 또 다른 이점은 관계형 데이터베이스, 문서형 데이터베이스, key/value 리파지토리 등 다른 형태의 저장 매커니즘으로도 쉽게 저장이 가능함
- 결과적 일관성을 사용해 다른 애그리게잇을 갱신
  - 도메인 이벤트를 통해 상태를 유지시킴
  - 메시징 비동기이므로 하나의 트랜잭션에서 처리되지 않음
  - 2개 이상의 애그리게잇을 단일한 트랜잭션으로 묶어서 처리하지 않아도 되기 때문에, 거대한 처리를 만들지 않을수 있음
  - 실제로 비지니스가 모든 상황에서 즉각적인 일관성을 요구할 가능성은 매우 낮음

### 애그리게잇 모델링
- Anemic Domain Model(빈약한 도메인 모델)로 만들지 않아야 함
  - 모델이 비지니스 행위가 아닌 단순한 Getter, Setter 로 사용되는 것을 말함
  - 이것은 비지니스 개념보다 기술에 초점이 맞춰진 것이라 볼 수 있음
- 비지니스 로직이 도메인을 넘어 어플리케이션 서비스까지 나가지 않도록 주의해야 함
  - helper, util 클래스에 위임하지 않도록 함
- 엔티티에 Setter 사용하지 않도록 함. Getter 는 사용해도 괜찮음

### 애그리게잇 함수형 프로그래밍
- 함수형 프로그래밍은 규칙이 많이 바뀜
- 빈약한 도메인 모델이 객체 지향에서 나쁜 생각인 반면, 함수형 프로그래밍에서는 일반적임
- 함수형 프로그래밍은 데이터와 행위를 분리하는 것을 권장함
  - 불변하는 데이터 구조를 설계하고 데이터 제어를 순수한 함수로 행위를 구현하는 방식
  - 인자로 받은 데이터를 수정하지 않고 새로운 값을 반환함

### 애그리게잇 추상화
- 추상화는 조심스럽게 사용해야함
- 현재의 보편언어 사용보다 미래의 모든 개념을 모델링하는 것에 더 많은 관심을 가지게 될 수 있음
- 덫에 현혹되지 말라

### 애그리게잇 올바른 크기
- 즉시 또는 적절한 트랜잭션으로 처리돼야 하는 것들은 동일한 애그리게잇으로 관리해야 함
- 다양한 엔티티 간에 발생하는 갱신의 수용 가능한 시간을 결정할 수 있는 것은 오직 비지니스 임
- 비지니스가 해야하는 일이 무엇인지를 고려하는 것이 매우 중요

### 애그리게잇 테스트 가능한 단위
- 복잡한 애그리게잇은 테스트하기 어려움
- 개인적인 의견
  - AI 가 쉽게 테스트 코드를 만들어 줄수 있는 단위가 적당하다고 생각



## Domain Events
- 도메인에 발생한 내용을 공유하는 것
- 도메인 이벤트 타입을 나타내는 이름은 과거에 발생한 것을 서술하는데, 이는 **과거형 동사**로 표현할 수 있음
- 도메인 이벤트 모델링
  - 식별자 ID, 필수적인 property 를 포함
  - 추가 쿼리를 하지 않도록 이벤트에 property 를 넣는 것이 일반적으로 좋음
  - 그러나 너무 많이 데이터를 넣는 것도 주의해야 함. 불필요한 정보는 이벤트를 이해하기 어렵게 만듬

### 도메인 이벤트 vs 명령
명령
- 비지니스를 처리할 수 없는 경우에 응답을 실패로 줄수 있음
  - 책에서는 응답 실패를 명령을 거부할수 있다고 표현하고 있는 것으로 보임

도메인 이벤트
- 이벤트는 이미 발생한 것이고 논리적으로 부정할 수 없음

### 도메인 이벤트 + 이벤트 소싱(Event Sourcing)
이벤트 소싱
- 애그리게잇 인스턴스에 발생했던 모든 도메인 이벤트를 이벤트 스토어에 저장하는 것을 이야기함
- 상태를 저장하는 것이 아닌 발생했던 도메인 이벤트 모두를 저장
- 이벤트 스토어는 순차적으로 추가만 하는 방식으로 저장
  - 이러인 이유로 매우 높은 처리량, 낮은 대기시간, 높은 확장성 을 가지게 됨

이벤트 소싱의 이점
- 도메인에서 발생하는 모든 기록을 개별적인 발생 수준으로 저장하여 비지니스 로직을 파악하기 좋음
- 디버깅, 이벤트 사용 추세등 파악하기 좋음
- CQRS(Command Query Responsibility Segregation) 를 적용하기 좋음


