# 소프트웨어의 본질
- 소프트웨어 사용자를 위해 도메인에 관련된 문제를 해결하는 것
- 그러나 도메인 연구는 대부분의 소프트웨어 프로젝트에서 최우선 과제로 여겨지지 않음 

## 객체지향 패러다임
- 객체의 가장 기본적인 개념 중 하나는 데이터와 해당 데이터를 대상으로 연산을 수행하는 로직을 캡슐화 하는 것

## Analysis Model(분석 모델)
- 업무 도메인의 개념만을 체계화하려고 만든 모델
- 오로지 이해하기 위한 수단으로 간주되며, 구현시 혼란만 초래하는 것으로 여겨짐

## Model Driven Design(모델 주도 설계)
- 순수하게 기술적인 쟁점은 배제하고, 객체는 모델에서 기술한 개념적 역할을 수행
- 문제를 분석하고 실제적인 설계를 제공하는 단일 모델을 개발해야 함
- 많은 개발자가 단지 프로그램 코드를 구성하는 데만 객체의 기술적 능력을 적용해 도움을 얻지만, 객체 설계의 진정한 도약은 코드가 모델의 개념을 표현할 때 나옴
- C 같은 언어를 사용할 때는 순수하게 절차적인 언어이기 때문에 모델 주도 설계를 적용하기 어려움

## Domain Model(도메인 모델)
- 기술은 아키텍처 전반에 걸쳐 산재해 있지만, 도메인 모델은 기술로부터 최대한 자유로워야 한다.
  - 예를 들면. 트랜잭션은 애플리케이션 서비스에 의해 관리되는 것이지, 도메인 모델에 의해 관리되는 것이 아니다.
- 모델이 구현, 설계, 의사소통의 기초가 되도록 해야하고, 팀내 보편언어를 모델에 끊임없이 적용하도록 함
- 도메인 전문가도 해당 모델을 이해하지 못한다면 모델이 뭔가 잘못된 것임

## Hand On Modeler(실천적 모델러)
- 모델을 설계하는 사람과 개발하는 사람이 분리되어 있다면, 설계대로 구현되지 않음
- 모델에 기여하는 모든 사람은 코드를 접하는데 시간을 투자해야 하며, 코드를 통해 모델을 표현하는 법을 배워야 함

---

# Model Driven Design
- Navigation Map
  [그림 DDD 67p]()

## Layered Architecture(계층형 아키텍처)
[그림 DDD 70p]()
- 복잡한 프로그램을 만들때 관심사의 분리(separation of concern)가 필요하고 일반적으로 Layered Architecture 가 사용되고 있음
- 각 계층은 설계 의존성을 오직 한 방향으로만 둬서 느슨하게 결합되도록 함
- 상위 계층은 하위 계층의 공개 인터페이스를 호출하고 하위 계층에 대한 참조를 가짐
- 하위 계층이 상위 계층과 소통해야 할 경우에 callback 이나 observer 패턴을 활용할 수 있음

### Layerd Architecture 단점
- 일반적으로 사용하는 계층형 아키텍처는 도메인이 인프라스트럭처에 의존하게 되어 테스트 코드 작성이나 코드 수정이 어려움
- 관점의 분리(separation of aspect) 가 도움되지만 티어 별로 코드가 쪼개지는 문제점이 있음
  - 각 티어의 기능을 쉽게 이해하고(기술적으로) 계층을 쉽게 파악할 수 있음
  - module 로 묶으려고 하면 계층별로 모듈이 만들어져야 하고 module 로 나누기 쉽지 않음
  - 기술적인 관점에 치중하다 보면 각 티어로 로직이 흩어지기 쉬움
    - 로직이 흩어지면 빈약한 도메인 모델이 만들어지고 로직이 보이지 않게 되어 기능 수정이 얼마나 걸릴지 알수 없음
  

## 도메인 주도 설계
- 도메인 주도 설계의 전제 조건은 도메인 계층을 격리하는 것에 있음.
  - 인터페이스, 애플리케이션, 인프라스트럭처 코드와 분리되어야 함
  - 핵사고날 아키텍처가 적합하다고 생각됨
- 도메인 계층은 업무 로직에 대한 설계와 구현으로 구성됨

## Smart UI - 안티패턴
- Smart UI 를 적용한다면 DDD 의 대부분을 적용할 수 없음
- 단점
  - 데이터베이스를 이용하는 방식 말고는 여러 애플리케이션을 통합하기가 수월하지 않음
  - 행위를 재사용하지 않으며, 업무 문제에 대한 추상화가 이뤄지지 않아, 업무 규칙이 적용되는 연산마다 업무 규칙이 중복됨
  - 신속한 프로토타입 작성과 Smart UI 가 지닌 태생적인 한계에 도달하게 되는데, 추상화의 부재로 리팩토링의 여지가 제한되기 때문
  - 복잡성에 금방 압도되어 애플리케이션의 성장 경로가 순전히 부가적인 단순 응용으로만 향하게 됨. 우아한 방법으로 더욱 풍부한 행위를 갖출 수 있는 방법이 없음

## 연관관계
- 도메인의 특성이 반영되게 연관관계를 제약하면 구현이 단순해짐
- 연관관계를 좀 더 쉽게 다루는 방법
  - 탐색 방향을 부여
  - 다중성(multiplicity)을 줄임
  - 중요하지 않은 연관관계를 제거


## Value Object(값 객체)
- 고유한 식별성이 없으며, 특징을 묘사하는데 사용
  - 설계 요소가 **어느것**인지에 대해서는 관심이 없고 오직 해당 요소가 **무엇인지**에 대해서만 관심이 있음
- 값 형태 속성을 비교함으로써 동일성이 결정됨
- 모델에 포함된 속성에만 관심이 있다면 value object 로 분류
- value object 를 구성하는 속성은 개념적 완전성(conceptual whole)을 형성해야함

### value object 의 설계
- 복사, 공유, 불변에 관한 의사결정이 필요
- value object 는 불변적(immutable)으로 다뤄야 함
  - 변경을 방지해서 객체를 안전하게 공유할수 있도록 함
  - 변경가능성을 허용하는 경우
    - value 가 자주 변경되는 경우
    - 객체 생성이나 삭제에 비용이 많이 드는 경우
    - 교체로 인해 클러스터링이 제한되는 경우
    - value 를 공유할 일이 많지 않거나 클러스터링을 향상시키기 위해서나 다른 기술적인 이유로 공유가 어려운 경우
- value object 는 많아지는 경향이 있으므로 성능 최적화를 생각해야 할 수 있음
- 복사 vs 공유 어느것이 경제성 면에서 더 나은지 환경에 따라 다름
- 다음과 같은 경우 공유를 사용
  - 공간을 절약하거나 데이터베이스내의 객체 수를 줄이는 것이 중요한 경우
  - 통신 부하가 낮은 경우(이를테면, 중앙집중형 서버)
  - 공유 객체의 불변성이 엄격하게 지켜지는 경우

## Entity(참조객체라고도 함)
- 속성이 아닌 식별성으로 객체를 정의하는데 이 객체를 Entity 라고 함
  - 다른 모델링 수단들과 entity의 구분은 유일성, 즉 독립성에 있음
- 상태는 계속 변할수 있지만 연속성은 유지해야 함
- 객체를 구별하는 수단을 정의하고 모델이 동일하다는 것이 무슨 의미인지 정의해야 함
  - 객체지향 언어에서 모든 객체에 내장된 동일성(identity) 연산으로 모든 객체가 식별성을 가지고 있다고 혼동하기도 함
- ex>
  - Customer 에서 고객ID 는 Entity 의 유일한 식별자임
  - 이름은 한 사람의 식별성을 정의하지 않지만 간혹 식별성을 판단하는 수단의 일부로 사용되기도 함

## Service
- service 는 모델에서 독립적인 인터페이스로 제공되는 연산으로, 활동(activity)이나 행동(action) 연산을 처리함
- 활동과 행동은 entity 나 value object 에 어울리지 않는 도메인 개념임
  - 이러한 도메인 개념을 강제로 객체에 포함시킨다면 리팩토링하기 어려워 짐
  - service 는 활동으로 이름을 짓지만, entity 는 주로 동사나 명사로 이름을 부여함
- service 는 상태를 갖지 않고 다른 객체와의 관계를 강조함
  - entity, value object 와 달리 캡슐화하지 않음  
- service 의 매개변수와 결과는 도메인 객체여야 함
- 설계가 매우 명확하더라도 개념적으로 어떠한 객체에도 속하지 않는 연산이 포함될 때가 있는데, 이때 service 를 모델에 명시적으로 포함할수 있음
  - 요건 책의 내용에 별로 동의할수 없음. service 를 모델에 넘기는건 개인적으로 좋지 않다고 생각함
- 객체를 사용하지 않고 절차적 프로그래밍에 빠지는 실수를 많이 하게 됨

### 서비스와 격리된 도메인 계층
- Service 는 도메인 계층에만 있는 것이 아니다.
- 도메인 계층에 속하는 Service 와 다른 계층에 속하는 Service 를 구분해야 한다.
  - 기술적인 프레임워크에서 사용하는 Service(spring service) 는 도메인 Service 와 다른 계층임을 인지해야함

계층 | 설명
--- | --- 
응용 | 입력(XML 요청과 같은) 내용의 암호화, 도메인 서비스로의 메시지 전송, 인프라스트럭처 서비스를 이용한 통지 결정
도메인 | 도메인 객체 간의 상호 작용
인프라스트럭처 | 애플리케이션에서 지정한 곳으로 이메일이나 우편을 전송

- 응용과 도메인을 구분하는 것은 어려울 수 있음
- 응용 서비스의 예시를 조금 더 들어보면
  - 은행 어플리케이션에서 거래 내역을 파일로 변환해 내보내는 기능이 있다고 하자
  - 은행 업무 도메인에서 "파일 형식" 은 의미가 없고 도메인 로직도 아님
- 도메인 객체와 외부 호출에서 입력을 받아들이는 FACADE(퍼사드)로 만들수 있음

## Module(모듈, 패키지)
- 오래전부터 확립되어 사용되고 있는 설계 요소
- 모듈화하는 주된 이유는 인지적 과부화(congnitive overload) 때문
- module 간에는 결합도가 낮아야 하고 module의 내부는 응집도가 높아야 한다.
- module 로 쪼개지는 것은 코드가 아닌 개념이다
- 모델이 이야기라면 module 은 이야기의 장에 해당


## 도메인 객체 생명주기 - aggregate, Factory, Repository
- aggregate 를 모델링하고 설계에 Factory, Repository 를 추가하면, 모델 객체의 생명주기를 체계적이고 의미있는 단위로 조작할 수 있음
- aggregate 는 생명주기의 전 단계에서 불변식이 유지돼야 할 범위를 표시해 줌
- Factory, Repository 는 aggregate 를 대상으로 연산을 수행하며, 생명주기로 옮겨가는데 따르는 복잡성을 캡슐화 함

## aggregate(애그리게잇)
### aggreate 정의
- 연관관계를 최소화하여 설계하더라도 결국 객체 참조를 통해 얽히고 설킨 관계를 추적해야 한다.
- 복잡한 연관관계를 맺는 객체를 대상으로 변경의 일관선을 보장하기 어렵다.
- 밀접한 관계에 있는 객체 집합에도 불변식이 적용돼야 하기 때문이다.
  - 불변식은 데이터가 변경될 때마다 유지돼야 하는 일관성 규칙을 뜻함
- 그렇다면 여러 객체로 구성된 객체의 범위는 어디서부터 어디까지일까?
- 데이터 변경의 단위로 다루는 연관관계의 묶음을 aggregate 라고 함

### aggreate 특성
- aggregate 는 root 와 boundary(경계)가 있음
  - boundary
    - aggregate 에 무엇이 포함되고 포함되지 않는지를 정의함
  - root
    - 1 개 이상의 entity 로 구성되고 그중에 하나의 entity 를 애그리게잇 루트라고 부름
- aggregate 경계 안의 객체는 서로 참조할 수 있지만, 경계 바깥의 객체는 root 만 참조할 수 있음
- 애그리게잇은 value object 를 포함할 수 있음
- 애그리게잇은 일관성 있는 트랜잭션 경계를 형성함
  - 여기서 트랜잭션은 디비의 트랜잭션이 아니라 비지니스 로직의 처리 단위라고 봐야함
- aggregate 경계 안의 어떤 객체를 변경하더라도 전체 aggregate 의 불변식은 모두 지켜져야 함.

### 애그리게잇 경험 법칙
- 애그리게잇 경계 내에서 비지니스 불변사항들을 보호
- 작은 애그리게잇으로 설계
  - 로직이 복잡하지 않으므로 이해하기 쉽고 테스트 코드 만들기도 좋음
  - 단일 책임 원칙 - SRP(Single Responsibility Principle)
    - 애그리게잇이 너무 많은 일을 하면 SRP 를 따르지 않는 것이고, 이후 애그리게잇 크기에 대해 재논의할 가능성이 큼
- 오직 ID 를 통해 다른 애그리게잇을 참고
  - 애그리게잇을 작게 유지하고, 동일한 트랜잭션 내에 여러 애그리게잇을 수정하려는 접근을 방지해 줌
  - ID 외에 다른 애그리게잇 내의 객체 레퍼런스를 얻어낼 수 있는 방법이 없음
  - 식별자만을 통해 레퍼런스를 얻는 규칙의 또 다른 이점은 관계형 데이터베이스, 문서형 데이터베이스, key/value 리파지토리 등 다른 형태의 저장 매커니즘으로도 쉽게 저장이 가능함
- 결과적 일관성을 사용해 다른 애그리게잇을 갱신
  - 도메인 이벤트를 통해 상태를 유지시킴
  - 메시징 비동기이므로 하나의 트랜잭션에서 처리되지 않음
  - 2개 이상의 애그리게잇을 단일한 트랜잭션으로 묶어서 처리하지 않아도 되기 때문에, 거대한 처리를 만들지 않을수 있음
  - 실제로 비지니스가 모든 상황에서 즉각적인 일관성을 요구할 가능성은 매우 낮음

### 애그리게잇 모델링
- Anemic Domain Model(빈약한 도메인 모델)로 만들지 않아야 함
  - 모델이 비지니스 행위가 아닌 단순한 Getter, Setter 로 사용되는 것을 말함
  - 이것은 비지니스 개념보다 기술에 초점이 맞춰진 것이라 볼 수 있음
- 비지니스 로직이 도메인을 넘어 어플리케이션 서비스까지 나가지 않도록 주의해야 함
  - helper, util 클래스에 위임하지 않도록 함
- entity 에 Setter 사용하지 않도록 함. Getter 는 사용해도 괜찮음

### 애그리게잇 함수형 프로그래밍
- 함수형 프로그래밍은 규칙이 많이 바뀜
- 빈약한 도메인 모델이 객체 지향에서 나쁜 생각인 반면, 함수형 프로그래밍에서는 일반적임
- 함수형 프로그래밍은 데이터와 행위를 분리하는 것을 권장함
  - 불변하는 데이터 구조를 설계하고 데이터 제어를 순수한 함수로 행위를 구현하는 방식
  - 인자로 받은 데이터를 수정하지 않고 새로운 값을 반환함

### 애그리게잇 추상화
- 추상화는 조심스럽게 사용해야함
- 현재의 보편언어 사용보다 미래의 모든 개념을 모델링하는 것에 더 많은 관심을 가지게 될 수 있음
- 덫에 현혹되지 말라

### 애그리게잇 올바른 크기
- 즉시 또는 적절한 트랜잭션으로 처리돼야 하는 것들은 동일한 애그리게잇으로 관리해야 함
- 다양한 entity 간에 발생하는 갱신의 수용 가능한 시간을 결정할 수 있는 것은 오직 비지니스 임
- 비지니스가 해야하는 일이 무엇인지를 고려하는 것이 매우 중요

### 애그리게잇 테스트 가능한 단위
- 복잡한 애그리게잇은 테스트하기 어려움
- 개인적인 의견
  - AI 가 쉽게 테스트 코드를 만들어 줄수 있는 단위가 적당하다고 생각




## Factory
- 도메인 객체 생명주기의 초기 단계로, 어떤 객체나 aggregate 를 생성하는 일이 복잡해지는 경우 캡슐화를 제공함
- 객체의 생성 생성과 조립은 도메인에서는 의미가 없지만 구현 측면에서는 반드시 필요함
  - 복잡한 객체를 조립하는 일은 조립이 완료된 객체가 하는 일과 관련성이 적음
  - 객체를 생성하는 것이 그 자체로도 주요한 연산이 될수 있지만 조립 연산은 생성된 객체의 책임으로 어울리지 않음
  - 복잡한 객체를 생성하는 일은 도에민 계층의 책임이지만, 그것이 모델을 표현하는 객체에 속하는 것은 아님
- 다른 클래스의 생성자 내에서 생성자를 호출하지 않도록 해야 한다.
  - 이럴꺼면 Factory 를 쓰자


### 클라이언트에서 객체 생성하는 로직을 넣지 않아야 하는 이유
- 클라이언트에서 자신이 원하는 도메인 객체를 직접 조립해야 한다면, 클라이언트는 도메인 객체의 내부 구조를 알아야 함
- 이렇게 되면 생성자를 호출하는 것만으로도 생성중인 객체의 구상 클래스와 클라이언트가 결합됨
- 클라이언트를 변경하지 않고는 도메인 객체의 구현을 변경할 수 없으며, 이로써 리팩토링이 더 힘들어짐

### Factory 설계 방법
- Factory method(팩터리 메서드)
- abstract Factory(추상 팩터리)
- builder(빌더)

### Factory 위치
- aggregate root 에 Factory method 를 생성
- 생성된 객체를 소유하지는 않지만 다른 객체를 만들어내는 것과 밀접한 관련이 있는 특정 객체에 fatory method 를 생성
- Factory 에서 만들어내는 객체와 매우 강하게 결합돼 있으므로 자신의 생성물과 가장 밀접한 관계에 있는 객체에 있어야 함
- 전용 Factory 객체나 service 를 만들어야 할 수도 있음

### Factory 설계 방법
- 복잡한 생성물을 만들어내는 데 필요한 것들을 모두 한번에 facotry 로 전달해야 함
  - 객체 생성 실패에 대해 코딩 표준을 도입하는 것도 고려해 볼 수 잇음
- 불변식 로직 위치
  - aggregate 처럼 여러 객체에 걸쳐 존재하는 경우, Factory 에 둬서 생성물에 들어 있는 복잡합 요소를 줄일수 있음
    - fatory 는 자신이 만들어 내는 생성물의 내부 구조를 알고 있기 때문
    - 객체가 생성된 이후 사용되지 않을 로직이라면 로직을 Factory 에 두어 생성물은 단순하게 함
  - Factory method 인 경우, 생성물에 위임하는게 최선일 때도 있음

### 저장된 객체의 재구성(reconstitution)
- 재구성이란?
  - 저장돼 있는 객체로부터 인스턴스를 만들어 내는 것
- 재구성에 사용되는 entity Factory 는 새로운 id 를 할당하지 않음
  - 저장된 객체를 재구성하는 Factory 의 입력 매개변수에는 반드시 식별 속성을 포함해야 함
- 새로운 객체를 생성하는 과정에 불변식이 충족되지 않는 경우 객체 생성을 멈추면 되지만, 재구성인 경우 중단시키면 바로 장애임.


## Repository
- 도메인 객체 생명주기의 중간과 마지막 단계로 인프라스트럭처를 캡슐화 하고 영속 객체를 다루는 수단을 제공함
- 중간 단계
  - 저장된 객체를 가져오는 것은 실제로는 생성의 한 부분집합으로 볼수 있음
  - 
### Repository 주의 사항
- 클라이언트 코드에서 직접적으로 데이터베이스를 사용할수록 개발자들은 aggregate 나 캡슐화 같은 특징을 활용하지 않고 우회하려 하고, 필요한 데이터를 직접 획득해서 조작하게 됨
- 도메인 로직은 질의와 클라이언트 코드로 들어가고, entity 와 value object 는 그저 데이터 컨테이너로 전락하게 됨
- 기술적 인프라스트럭처와 데이터베이스 접근 매커니즘을 드러내면 클라이언트가 복잡해지고 model driven design 도 불분명 해짐
- 이러한 이유로 대부분의 객체는 전역적인 검색으로 접근하지 않도록 해야 함

### Repository 설계
- Repository 는 특정 타입의 모든 객체를 하나의 개념적 집합으로 나타냄
- Repository 는 요청된 객체를 가져오며, 데이터베이스 질의 및 메타데이터 매핑을 캡슐화함
  - 클라이언트의 부담을 덜어줘서 단순하고 의도를 드러낼 수 있도록 함
- Repository 는 컬렉션 처럼 동작
  - 전역적인 접근이 필요한 각 객체 타입에 대해 메모리 상에 해당 타입의 객체로 구성된 컬렉션이 있다는 착각을 불러일으키는 객체를 만듬
- 객체를 추가하고 제거하는 메서드를 제공
  - 실제로 데이터 저장소에 데이터를 삽입하고 제거하는 연산을 캡슐화
- 특정한 기준으로 객체를 선택하고 속성값이 특정 기준을 만족하는 객체나 객체 컬렉션을 반환해야 하는 메서드를 제공
  - 실제 저장소와 질의 기술을 캡슐화
- aggregate root 에 대해서만 Repository 를 제공
  - 모든 객체 저장과 접근은 Repository 에 위임해서 클라이언트가 모델에 집중하게 함

### Repository 이점
- 객체의 생명주기를 관리하기 위한 단순한 모델을 클라이언트에게 제시
- 영속화 기술과 다수의 데이터베이스 전략, 다수의 데이터 소스로 부터 애플리케이션과 도메인 설계를 분리
- 객체 접근에 관한 설계를 결정을 전해줌
- 테스트에서 사용할 가짜 구현을 손쉽게 대체할 수 있음(메모리 상의 컬렉션을 이용)

### Repository 구현
- 영속화에 사용되는 기술과 인프라스트럭처에 따라 구현이 매우 다양해짐
- 클라이언트에서 모든 내부 기능을 감춰서(클라이언트 개발자에게는 감출수 없지만..), 데이터가 어디 저장되든 클라이언트 코드를 동일하게 유지하도록 해야함
- 타입을 추상화 함
  - 특정 타입의 모든 인스턴스를 담기는 하지만 이 각 클래스마다 하나의 Repository 가 필요하다는 의미는 아님
- 클라이언트와의 분리를 활용
  - 클라이언트에서 직접 매커니즘을 호출했을 때보다 더 자유롭게 Repository 의 구현을 변경할 수 있음
- 트랜잭션 제어를 클라이언트에 둠
  - 데이터베이스에 대한 삽입과 삭제를 Repository 에서 수행하겠지만, Repository 에서 아무것도 커밋(commit)하지 않음

### Repository 질의하기
- Specification(명세) 에 기반을 둔 질의를 사용


### Repository 프레임워크
- 프레임워크와 model driven design 의 여러 패턴 간의 개념적 유사성을 찾아봄으로써, 프레임워크에 entity 를 aggregate root 에 쓰는 것으로 결정할 수 도 있음
  - 프레임워크에 entity 와 도메인 주도 개발의 entity 는 같은 것이 아니라는 것을 명심해야 함
- 그러나 프레임워크에 entity 를 사용하면 도메인 주도 설계의 원칙을 유지할수 없게 됨

### Repository 와 Factory
- Factory 가 객체 생애의 초기 단계를 다루는데 반해 Repository 는 중간과 마지막 단계를 관리하는데 사용함
- Factory 가 새로운 객체를 만들어 내는 데 반해 Repository 는 기존 객체를 찾아냄
  - 기존 객체를 찾고 재구성해야 할지도 모르지만 그것은 동일한 개념적 객체이며, 여전히 객체 생명주기 상의 중간 단계에 해당함
- Repository 가 처음으로 객체를 생성할때, Factory 로 객체 생성을 위임할 수 있음
- Factory 와 Repository 를 결합하게 만드는 경우는 (find or create) 기능을 원할때 인데, 이 기능은 사용하는 것을 자제해야 함
- 일반적으로 새로운 객체와 이미 존재하는 객체를 구분하는 것은 도메인에서 중요하며, Factory 와 Repository 가 결합되면 상황을 엉망으로 만들수 있음


## Deep Model(심층 모델)
- 도메인의 피상적인 측면은 배제하고 도메인 전문가의 주요 관심사와 가장 적절한 지식을 알기 쉽게 표현 하는 모델

## Specification(명세)
- 특정한 종류의 규칙을 표현하는 매우 간결한 수단을 제공함
- 조건 로직으로부터 규칙을 분리해서 규칙이 모델 내에서 분명해지게끔 만들어 줌
- 규칙을 도메인 계층 내에 유지할 필요가 있는데 명세를 이용하면 도메인 계층에 유지 가능함
- 규칙을 통해 평가하려는 객체에 규칙을 두기에는 적절하지 않음
  - 규칙을 평가하는 메서드는 조건 코드로 팽창할 것이고 결국 규칙에 대한 가독성은 떨어짐
- 완전한 객체를 사용해서 규칙을 표현하므로 설계가 모델을 더욱 명확하게 반영할 수 있음
- Factory 는 외부정보를 사용해 Specification 을 설정할 수 있음

### Specification 이란?
- 다른 객체에 대한 제약조건을 기술하며, 제약조건은 존재할 수도 존재하지 않을 수도 있음
- 특별한 목적을 위해 술어와 유사한 명시적인 value object 를 만들어라.
- 어떤 객체가 특정 기준을 만족하는지 판단하는 술어이다.
- 단순 명제들을 결합하도록 개념을 확장할 수 있음

### Specification 용도 
- 객체가 어떤 요건을 충족시키거나 특정 목적으로 사용할 수 있는지 가늠하고자 **객체를 검증(validation)**
- 컬렉션 내의 **객체를 선택(selection)**
- 특정한 요구 사항을 만족하는 **새로운 객체의 생성을 명시(building to order)**
- 세가지 용도는 개념적 차원에서 동일함

#### Specification 검증

~~~java
Specification delinquentSpec = new DelinquentInvoiceSpecification(date);
if (delinquentSpec.isSatisfiedBy(candidate)) return true;
~~~

#### Specification 선택

~~~java
Set delinquentInvoices = repository.selectSatisfying(new DelinquentInvoiceSpecification(date))
~~~

#### Specification 요청 구축(생성)
- 생성기의 구현을 인터페이스로부터 분리할 수 있음
  - 생성할 결과물에 요구사항을 선언하지만 결과물을 생성하는 방법은 정의하지 않음
- 생성 규칙을 명시적으로 전해주므로 개발자들이 연산의 세부적인 사항을 이해하지 않고도 생성기의 결과물을 예상할 수 있음
  - 절차적인 방식으로 정의된 생성기의 경우 어떻게 작동할지 예상하려면 직접 실행해보거나 코드를 한줄한줄 읽어보고 이해하는 수 밖에 없음
- 생성 요청을 표현하는 코드는 클라이언트에 존재하므로 더 유연한 인터페이스를 얻거나 더 유연하게 개선할 수 있음
- 생성기에 대한 입력을 정의하는 명시적인 방법이 모델에 포함돼 있어서 테스트하기가 더 수월


## 유연한 설계(supple design)
- 레거시 코드로 인한 중압감에 시달라지 않고 프로젝트 진행을 촉진하려면 변경을 수용하고 즐겁게 작업할 수 있는 설계

### 의도를 드러내는 인터페이스 (intention revealing interface)
- 수행 방법에 관해서는 언급하지 말고 결과와 목적만을 표현하도록 클래스와 연산의 이름을 부여하라
- 클라이언트 개발자 관점에서 생각하기 위해 클래스와 연산을 추가하기 전에 행위에 대한 테스트를 먼저 작성하라

### 부수효과가 없는 함수(side effect free function)
- 복잡한 로직을 value object 로 옮겨서 부수효과를 통제하라
  - value object 는 value object 를 생성할 때 호출되는 초기화 연산을 제외한 모든 연산은 함수이다.
  - 함수는 여러번 호출해도 무방하며 매번 동일한 값을 반환하여, 부수효과를 일으키지 않음
- 명령(command)과 질의(query) 를 분리함
  - query 가 side effect free function 이라고 보면 될듯

### 단언(assertion)
- 부수효과를 초래하는 명령(command)의 영향력은 assertion 을 사용하면 부수효과가 명확해지고 다루기 쉬워짐
  - 단언에는 절차를 기술하지 않고 상태만 기술하므로 분석하기가 쉬움
- 프로그램 코드에 직접 assertion 을 명시하라
- assertion 을 명시할 수 없다면 단위 테스트를 작성해서 assertion 의 내용을 표현하라

### 개념적 윤곽(conceptual contour)
- 모델 또는 설계를 구성하느 요소가 모놀리식 구조에 있을 경우 각 요소의 기능이 중복될수 있음
- 클래스와 메서드를 잘게 나누면 객체가 무의미하게 복잡해짐
- 개념적으로 의미있는 기능의 단위를 개념적 윤곽이라고 볼수 있을것 같음

### 독립형 클래스(standalone class)
- 극단적으로 결합도를 낮춘 클래스를 이야기 하는듯

### 연산의 닫힘(closure of operation)
- 닫힌 연산은 부차적인 개념을 사용하지 않고도 고수준의 인터페이스를 제공한다.
  - 도메인 연산이 불변 조건을 위반하지 않도록 스스로 상태를 조정하도록 함
  - 외부에 로직 분산을 막고 도메인 중심으로 책임을 집중
  - 일관성 있는 상태 유지, 유지보수 쉬운 코드

### 선언적 설계(declarative design)
- 실행 가능한 명세로서 프로그램을 작성하는 방식으로, 특성을 정확하게 기술함으로써 소프트웨어를 제어 함

#### 도메인 특화 언어 - 사용하지 말자
- 선언적인 형식을 취하는 흥미로운 접근법
- 특정 도메인을 위해 구축된 프로그래밍 언어를 사용해 클라이언트 코드를 작성
  - 나만의 라이브러리 만들어 쓰는거를 말하는 듯
- 쓰지 말자
  - 모델을 개선하려면 개발자가 언어를 수정할 수 있어야 함
  - 수정된 모델과 도메인 특화 언어를 준수하도록 클라이언트 코드를 리팩토링하기 어려움

#### Specification 을 선언적인 형식으로 확장
- 논리 연산(and, or, not)을 사용한 Specification 의 조합
- 논리 연산은 closure of operation 을 의미

### 하위 도메인으로 분할
- 전체 설계 영역을 동시에 다룰 수 없음. 조금씩 뜯어 내야 함

## Strategy (전략, Policy<정책>라고도 함)
- 프로세스에 변화하는 부분을 별도의 전략 객체로 분리해서 모델에 표현하라
- 프로세스의 규칙과 프로세스를 제어하는 행위를 서로 분리하라

## Composite (복합체)
- Composite 내부에 포함된 모든 구성요소를 포괄하는 추상 타입을 정의 하라

## Flyweight
- 도메인 모델과 전혀 관련 없는 패턴
- value object 를 flyweight 로 구현하는 것이 적절함
- entity 에 flyweight 를 적용할 수 없음


---

# 전략적 설계

## Bounded Context(바운디드 컨텍스트)
- 도메인 모델을 분리하는 전략적 설계 패턴
- 동일한 context 의 범위를 표현(도메인 범위라고 생각함, MSA 에 마이크로 서비스 또는 도메인 서비스를 이야기 함)
- 모델이 구현되는 곳이고 bounded context 마다 각각 분리된 소프트웨어 산출물이 나옴
- 단일 팀에만 할당돼야하고 독립적인 소스 코드 리파지토리가 있어야함
- bounded context 마다 소스 코드와 데이터베이스 스키마도 명확히 분리 해야함
- 핵심이 되는 개념들은 포용하고 나머지는 모두 제외시켜야 함

### Problem Space(문제 영역), Solution Space(해결 영역)
- 문제 영역
  - 목표에 대해 이야기 하는 영역으로 간단한 다이어그램을 사용할 수도 있음
- 해결 영역
  - 문제 영역에서 논의된 것을 핵심 도메인으로 해결 방안을 구현하는 영역

### 핵심 도메인
- bounded context 가 조직의 핵심 계획으로 개발되고 있을때 이를 핵심 도메인이라고 함




## Ubiquitous Language(보편언어)
- bounded context 안에서 일하는 모든 팀 구성원이 사용하는 언어를 이야기함
- 팀 모두가 언어가 가진 제약 사항과 정확한 의미를 이해하고 있어야함.
- 소프트웨어 모델 안에 구현되기 때문에 엄격, 정확, 엄중, 단호 해야함
- 시나리오를 작성함으로써 보편언어 개발을 시작할 수 있음


### 시나리오
- 소프트웨어 프로젝트에서 흔히 말하는 유스케이스나 사용자 스토리 같은 것을 의미하지 않음
- 도메인 모델이 어떻게 동작할 것인지를 나타내는 세부사항을 시나리오로 만들어야 함

### 행위 주도 개발 - BDD(Behavior Driven Development) 
- 목적은 보편언어와 모델이 시나리오를 준수하고 있는지 확인하기 위함
- given / when / then 을 사용해 작성한 시나리오를 검증
- 장점은 신속하게 시나리오를 검증할 수 있음



## SubDomains(서브도메인)
- 서브 도메인 개념은 그냥 일반적인 마이크로 서비스에 포함된 여러 도메인을 의미하는 것이라고 생각됨
- 서브 도메인 유형
  - 핵심 도메인: 보편언어
  - 지원 서브 도메인
  - 일반 서브 도메인
- 레거시 시스템을 논리적 도메인 모델로 쪼개서 각각의 모델 할당을 서브도메인으로 사용할 수 있음
- bounded context 와 subdomains 는 1:1 관계가 되도록 함
  - subdomains 이 2개 일때 2개의 bounded context 로 분리하는 것이 좋지만, 현실적으로 어렵다면 모듈로 분리


## Context Mapping(컨텍스트 매핑)
- 핵심 도메인을 다른 bounded context 와 통합하는 방법
  - 다른 마이크로 서비스와 어떻게 연결시킬거냐에 대한 내용

### 컨텍스트 매핑의 종류
- 파트너십
  - 두 팀이 매우 밀접한 관련이 있기 때문에 상호간 의존적인 작업이나 여러 일정들을 조율하고 지속적으로 통합하는 노력이 필요함
- Shared Kernel(공유 커널)
  - 팀 사이에 공통인 모델을 공유하는 관계
- Downstream(고객) - Upstream(공급자)
  - 고객이 원하는 것을 제공해야 하기 때문에 공급자가 관계를 주도함
  - 고객이 언제 무엇을 받게 될지는 공급자가 결정
- Conformist(준수자)
  - 고객이 공급자의 보편언어를 계속 변환하는 것이 어렵기 때문에, 공급자의 모델을 그대로 따르는 것을 이야기 함
  - ex> 판매자가 아마존 시스템과 통합하려고 할때 판매자는 아마존 모델을 사용하게 됨
- Anticorruption Layer(반부패 계층)
  - 가장 방어적인 컨텍스트 매핑 관계
  - 공급자의 모델을 고객의 모델로 번역하는 계층을 만드는것
  - 통합에 용이, 외부의 이질적인 개념으로 부터 독립성을 유지
  - 모델 변경 작업의 비용이 높아질 수 있음
- Open Host Service(공개 호스트 서비스)
  - bounded context 에 대한 접근을 제공하는 프로토콜이나 인터페이스를 정의
  - 프로토콜: 모두가 용이하게 사용할 수 있도록 공개되어 있음
  - 인터페이스: API(application programming interface)로 제공하는 서비스
  - 수많은 레거시 시스템을 맞닥뜨리는 것보다 API 로 접근하는 것이 괜찮은 선택일 수 있음
- 공표된 언어
  - XML 스키마, JSON 스키마, Protobuf, Avro 로 정의할 수 있음  
- Separate Ways(각자의 길)
  - 외부 연동하지 않고 bounded context 에 내부적으로 구현하는 것을 이야기 함


### 컨텍스트 매핑 인터페이스
- SOAP(Simple Object Access Protocol) 를 이용한 RPC(Remote Procedure Calls)
  - 다른 시스템이 서비스를 사용할 때 로컬 프로시저나 메서드를 호출하는 것처럼 사용한다는 개념
  - 이 방식은 견고함이 떨어질 수 있다는 문제점이 있음 
    - 네트워크 장애나 지연이 생길수 있음
    - 네트워크에 문제가 생기면 호출은 에러 결과만 받은 채 실패하게 됨
  - 사용하기 쉬워 보인다고 해서 속으면 안됨
- RESTful HTTP
  - 공개 호스트 서비스와 공표된 언어를 제공해야 함
  - 도메인 모델 안에 직접적으로 애그리게잇을 반영하는 REST 리소스를 설계하는 실수를 많이 함
    - 도메인 모델이랑 REST 리소스 모델이랑 분리해서 쓰라는 이야기(Domain -> DTO 로 변환)
- 메시징(Publish - Subscribe)
  - 가장 견고한 형태의 통합
  - 즉각적인 결과가 필수적이지 않을때 메시징을 이용해 견고한 시스템을 구축하는 것이 좋은 선택임
  - 매시징 매커니즘
    - At-least-once delivery(적어도 한번의 전달)을 통해 모든 메시지의 수신을 보장
      - 메시지가 여러번 전달될 수 있음
    - 구독 bounded context 는 Idempotent Receiver(멱등 수신자)로 구현돼야 함
      - 여러번 수행되더라도 동일한 결과가 되도록 만드는 방식

### 컨텍스트 매핑 사례
- 모두 담는 것 vs 다시 쿼리하는 것 사이의 장단점




## Context Map
- 2개의 Bounded Context 를 통합하면서 그 사이에 존재하는 팀의 관계, 기술적 매커니즘을 정의




# 전술적 설계

## Domain Events
- 도메인에 발생한 내용을 공유하는 것
- 도메인 이벤트 타입을 나타내는 이름은 과거에 발생한 것을 서술하는데, 이는 **과거형 동사**로 표현할 수 있음
- 도메인 이벤트 모델링
  - 식별자 ID, 필수적인 property 를 포함
  - 추가 쿼리를 하지 않도록 이벤트에 property 를 넣는 것이 일반적으로 좋음
  - 그러나 너무 많이 데이터를 넣는 것도 주의해야 함. 불필요한 정보는 이벤트를 이해하기 어렵게 만듬
- 도메인 이벤트를 순서에 따라 저장하는 것이 다른 노드들에 동일한 순서를 보장하지 않음?
- 

### 도메인 이벤트 vs 명령
명령
- 비지니스를 처리할 수 없는 경우에 응답을 실패로 줄수 있음
  - 책에서는 응답 실패를 명령을 거부할수 있다고 표현하고 있는 것으로 보임

도메인 이벤트
- 이벤트는 이미 발생한 것이고 논리적으로 부정할 수 없음

### 도메인 이벤트 + 이벤트 소싱(Event Sourcing)
이벤트 소싱
- 애그리게잇 인스턴스에 발생했던 모든 도메인 이벤트를 이벤트 스토어에 저장하는 것을 이야기함
- 상태를 저장하는 것이 아닌 발생했던 도메인 이벤트 모두를 저장
- 이벤트 스토어는 순차적으로 추가만 하는 방식으로 저장
  - 이러인 이유로 매우 높은 처리량, 낮은 대기시간, 높은 확장성 을 가지게 됨

이벤트 소싱의 이점
- 도메인에서 발생하는 모든 기록을 개별적인 발생 수준으로 저장하여 비지니스 로직을 파악하기 좋음
- 디버깅, 이벤트 사용 추세등 파악하기 좋음
- CQRS(Command Query Responsibility Segregation) 를 적용하기 좋음


